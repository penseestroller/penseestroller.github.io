<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ASP.NET Core框架原理</title>
      <link href="/articles/dev/aspnet-core-mini/"/>
      <url>/articles/dev/aspnet-core-mini/</url>
      
        <content type="html"><![CDATA[<hr><p>蒋金楠，曾在微软技术（苏州）俱乐部成立大会上分享一个“迷你版”的ASP.NET Core框架，阐述了ASP.NET Core最核心、最本质的原理。本文对这个ASP.NET Core框架进行整理和学习。<br>地址：<a href="https://www.cnblogs.com/artech/p/inside-asp-net-core-framework.html" target="_blank" rel="noopener">https://www.cnblogs.com/artech/p/inside-asp-net-core-framework.html</a></p><a id="more"></a><h3 id="1-ASP-NET-Core介绍"><a href="#1-ASP-NET-Core介绍" class="headerlink" title="1. ASP.NET Core介绍"></a>1. ASP.NET Core介绍</h3><p><code>ASP.NET Core</code> 是一个新的开源和跨平台的框架，用于构建如 <code>Web</code> 应用、物联网<code>(IoT)</code>应用和移动后端应用等连接到互联网的基于云的现代应用程序。<code>ASP.NET Core</code> 应用可运行于 <code>.NET Core</code> 和完整的 <code>.NET Framework</code> 之上。 构建它的目的是为那些部署在云端或者内部运行<code>(on-premises)</code>的应用提供一个优化的开发框架。它由最小开销的模块化的组件构成，因此在构建你的解决方案的同时可以保持灵活性。你可以在 <code>Windows</code>、<code>Mac</code> 和 <code>Linux</code> 上跨平台的开发和运行你的 <code>ASP.NET Core</code> 应用。 <code>ASP.NET Core</code> 开源在 <code>GitHub</code> 上。</p><h3 id="2-ASP-NET-Core-Mini"><a href="#2-ASP-NET-Core-Mini" class="headerlink" title="2. ASP.NET Core Mini"></a>2. ASP.NET Core Mini</h3><p>GitHub地址：<a href="https://github.com/penseestroller/ASPDNC" target="_blank" rel="noopener">https://github.com/penseestroller/ASPDNC</a></p><h4 id="2-1-简单示例"><a href="#2-1-简单示例" class="headerlink" title="2.1 简单示例"></a>2.1 简单示例</h4><p>我们在控制台或<code>Winform</code>程序中通常使用<code>HttpListener</code>来托管<code>Http</code>服务，<code>ASP.NET Core</code>本质上也是控制台的程序。下面我们来设计一个简单的<code>Http</code>服务:</p><p><code>Program.cs</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span> &#123;</span><br><span class="line">        HttpListener httpListener = <span class="keyword">new</span> HttpListener();</span><br><span class="line">        httpListener.Prefixes.Add(<span class="string">"http://localhost:8000/"</span>);</span><br><span class="line">        httpListener.Start();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> context = <span class="keyword">await</span> httpListener.GetContextAsync();</span><br><span class="line">            <span class="keyword">await</span> context.Response.OutputStream.WriteAsync(Encoding.UTF8.GetBytes(<span class="string">"Hello World!"</span>));</span><br><span class="line">            context.Response.Close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在浏览器中访问：<code>http://localhost:8000/</code>，会显示 <code>Hello World!</code></p><h4 id="2-2-架构设计"><a href="#2-2-架构设计" class="headerlink" title="2.2 架构设计"></a>2.2 架构设计</h4><p>ASP.NET Core具有一个极具扩展性的请求处理管道，我们可以通过这个管道的定制来满足各种场景下的HTTP处理需求。<br>我们可以设计一个管道：<code>Pipeline = Server + HttpHandler</code><br><code>Http</code>的处理流程是：对请求<code>(Request)</code>的监听、接收，然后对请求信息进行处理，处理完成后，形成响应<code>(Response)</code>,这个处理过程由服务器<code>(Server)</code>来完成。<code>Server</code>可以将一个请求进行多节点的处理，然后形成一个最终的响应，各节点之间都是按照请求+处理+响应的模式处理，形成一条管道。这些请求处理节点我们称之为“中间件<code>(Middleware)</code>”,每个中间件都是具有独立的功能。<br><img src="/blog_images/aspnet_core_mini/pipeline2.png" alt="pipeline2"></p><h4 id="2-3-核心对象"><a href="#2-3-核心对象" class="headerlink" title="2.3 核心对象"></a>2.3 核心对象</h4><h5 id="2-3-1-HttpContext"><a href="#2-3-1-HttpContext" class="headerlink" title="2.3.1 HttpContext"></a>2.3.1 HttpContext</h5><p>请求处理管道由一个服务器和多个中间件构建，面向传输层的服务器负责请求的监听、接收和最终的响应，当它接收到客户端发送的请求后，需要将它分发给后续中间件进行处理。对于某个中间件来说，当我们完成了自身的请求处理任务之后，在大部分情况下也需要将请求分发给后续的中间件。请求在服务器与中间件之间，以及在中间件之间的分发是通过共享上下文的方式实现的。<br><img src="/blog_images/aspnet_core_mini/pipeline.png" alt="pipeline"><br>如图所示，当服务器接收到请求之后，会创建一个通过<code>HttpContext</code>的上下文对象，所有中间件都是对这个上下文进行处理的。<br>我们定义上下文对象<code>(Context)</code>，他封装了<code>Http</code>请求<code>(Request)</code>和响应<code>(Response)</code></p><p><code>HttpContext.cs</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HttpContext</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> HttpRequest Request &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> HttpResponse Response &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HttpRequest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Uri Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>;&#125;</span><br><span class="line">    <span class="keyword">public</span> NameValueCollection Headers &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Stream Body &#123; <span class="keyword">get</span>; <span class="keyword">set</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HttpResponse</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> NameValueCollection Headers &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Stream Body &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> StatusCode &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-2-Server"><a href="#2-3-2-Server" class="headerlink" title="2.3.2 Server"></a>2.3.2 Server</h5><p>服务器<code>(Server)</code>用来执行处理器的对象。他有一个启动方法，传入处理器并执行处理。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IServer</span>&#123;</span><br><span class="line">    <span class="function">Task <span class="title">StartAsync</span>(<span class="params">RequestDelegate handler</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里涉及到一个问题，就是<code>HttpContext</code>和<code>Server</code>之间的适配，<code>ASP.NET Core</code> 适用于多平台，也就是说会有不同的服务器，需要去处理<code>HttpContext</code>,我们怎么才能做到这个<code>HttpContex</code>t适用所有的<code>Http</code>服务器呢？“计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决” ，可以设计一套抽象的接口，来反映<code>HttpContext</code>。<br><img src="/blog_images/aspnet_core_mini/Server.png" alt="server"><br>如上图所示，我们定义统一的<code>Request</code>和<code>Response</code>接口，来适配不同的<code>Server</code>。<br>我们可以定义一系列的<code>Feature</code>接口来实现<code>Request</code>和<code>Response</code>，那么具体的服务器只需要实现这些<code>Feature</code>接口就可以了。</p><p><code>Features.cs</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IRequestFeature</span> &#123;</span><br><span class="line">    Uri Url &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    NameValueCollection Headers &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    Stream Body &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IResponseFeature</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> StatusCode &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    NameValueCollection Headers &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    Stream Body &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FeatureCollection.cs</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface IFeatureCollection : IDictionary&lt;Type, object&gt; &#123; &#125;</span><br><span class="line"></span><br><span class="line">public class FeatureCollection : Dictionary&lt;Type, object&gt;, IFeatureCollection &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Extensions</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T Get&lt;T&gt;(<span class="keyword">this</span> IFeatureCollection features) =&gt; features.TryGetValue(<span class="keyword">typeof</span>(T), <span class="keyword">out</span> <span class="keyword">var</span> <span class="keyword">value</span>) ? (T)<span class="keyword">value</span> : <span class="keyword">default</span>(T);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IFeatureCollection Set&lt;T&gt;(<span class="keyword">this</span> IFeatureCollection features, T feature) &#123;</span><br><span class="line">        features[<span class="keyword">typeof</span>(T)] = feature;</span><br><span class="line">        <span class="keyword">return</span> features;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改<code>HttpContext.cs</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HttpContext</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> HttpRequest Request &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> HttpResponse Response &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpContext</span>(<span class="params">IFeatureCollection features</span>)</span> &#123;</span><br><span class="line">        Request = <span class="keyword">new</span> HttpRequest(features);</span><br><span class="line">        Response = <span class="keyword">new</span> HttpResponse(features);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HttpRequest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IRequestFeature _feature;</span><br><span class="line">    <span class="keyword">public</span> Uri Url =&gt; _feature.Url;</span><br><span class="line">    <span class="keyword">public</span> NameValueCollection Headers =&gt; _feature.Headers;</span><br><span class="line">    <span class="keyword">public</span> Stream Body =&gt; _feature.Body;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpRequest</span>(<span class="params">IFeatureCollection features</span>)</span> =&gt; _feature = features.Get&lt;IRequestFeature&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HttpResponse</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IResponseFeature _feature;</span><br><span class="line">    <span class="keyword">public</span> NameValueCollection Header =&gt; _feature.Headers;</span><br><span class="line">    <span class="keyword">public</span> Stream Body =&gt; _feature.Body;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> StatusCode &#123; <span class="keyword">get</span> =&gt; _feature.StatusCode; <span class="keyword">set</span> =&gt; _feature.StatusCode = <span class="keyword">value</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpResponse</span>(<span class="params">IFeatureCollection features</span>)</span> =&gt; _feature = features.Get&lt;IResponseFeature&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Extensions</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Task <span class="title">WriteAsync</span>(<span class="params"><span class="keyword">this</span> HttpResponse response, <span class="keyword">string</span> contents</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> buffer = Encoding.UTF8.GetBytes(contents);</span><br><span class="line">        <span class="keyword">return</span> response.Body.WriteAsync(buffer, <span class="number">0</span>, buffer.Length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们来实现这个服务器，使用<code>HttpListener</code>来托管服务,<code>HttpListenerFeature.cs</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HttpListenerFeature</span> : <span class="title">IRequestFeature</span>, <span class="title">IResponseFeature</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> HttpListenerContext _context;</span><br><span class="line"></span><br><span class="line">    Uri IRequestFeature.Url =&gt; _context.Request.Url;</span><br><span class="line">    NameValueCollection IRequestFeature.Headers =&gt; _context.Request.Headers;</span><br><span class="line">    NameValueCollection IResponseFeature.Headers =&gt; _context.Response.Headers;</span><br><span class="line">    Stream IRequestFeature.Body =&gt; _context.Request.InputStream;</span><br><span class="line">    Stream IResponseFeature.Body =&gt; _context.Response.OutputStream;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> StatusCode &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _context.Response.StatusCode; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; _context.Response.StatusCode = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;       </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpListenerFeature</span>(<span class="params">HttpListenerContext context</span>)</span> =&gt; _context = context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HttpListenerServer.cs</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HttpListenerServer</span> : <span class="title">IServer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> HttpListener _listener;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="keyword">string</span>[] _urls;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpListenerServer</span>(<span class="params"><span class="keyword">params</span> <span class="keyword">string</span>[] urls</span>)</span> &#123;</span><br><span class="line">        _listener = <span class="keyword">new</span> HttpListener();</span><br><span class="line">        _urls = urls.Any() ? urls : <span class="keyword">new</span> <span class="keyword">string</span>[] &#123; <span class="string">"http://localhost:8000/"</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">StartAsync</span>(<span class="params">RequestDelegate handler</span>)</span> &#123;</span><br><span class="line">        Array.ForEach(_urls, url =&gt; _listener.Prefixes.Add(url));</span><br><span class="line">        _listener.Start();</span><br><span class="line">        Console.WriteLine(<span class="string">"Server started and is listening on: &#123;0&#125;"</span>, <span class="keyword">string</span>.Join(<span class="string">';'</span>, _urls));</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> listenerContext = <span class="keyword">await</span> _listener.GetContextAsync();</span><br><span class="line">            <span class="keyword">var</span> feature = <span class="keyword">new</span> HttpListenerFeature(listenerContext);</span><br><span class="line">            <span class="keyword">var</span> features = <span class="keyword">new</span> FeatureCollection()</span><br><span class="line">                .Set&lt;IRequestFeature&gt;(feature)</span><br><span class="line">                .Set&lt;IResponseFeature&gt;(feature);</span><br><span class="line">            <span class="keyword">var</span> httpContext = <span class="keyword">new</span> HttpContext(features);</span><br><span class="line">            <span class="keyword">await</span> handler(httpContext);</span><br><span class="line">            listenerContext.Response.Close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改下程序入口<code>Main</code>方法，测试运行：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span> &#123;   </span><br><span class="line">    IServer server = <span class="keyword">new</span> HttpListenerServer();</span><br><span class="line">    <span class="function"><span class="keyword">async</span> Task <span class="title">fooBar</span>(<span class="params">HttpContext httpContext</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> httpContext.Response.WriteAsync(<span class="string">"FooBar"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> server.StartAsync(fooBar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:<br><img src="/blog_images/aspnet_core_mini/main1.png" alt="main1"></p><h4 id="2-3-中间件-Middleware"><a href="#2-3-中间件-Middleware" class="headerlink" title="2.3 中间件(Middleware)"></a>2.3 中间件(Middleware)</h4><h5 id="2-3-1-Handler"><a href="#2-3-1-Handler" class="headerlink" title="2.3.1 Handler"></a>2.3.1 Handler</h5><p><code>HttpHandler</code>:<code>Http</code>处理器，处理请求<code>(Request)</code>返回响应<code>(Response)</code>。可以考虑有这么一个处理方法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task <span class="title">Handle</span>(<span class="params">HttpContext context</span>)</span>;</span><br></pre></td></tr></table></figure><p>如何来表示这个<code>Handler</code>？我们需要同步或者异步的处理请求和响应，那个考虑使用<code>Task</code>对象，这样我们设计一个返回<code>Task</code>的委托，来灵活的实现这个处理器：<br>常规思维，直接定义一个<code>HttpHandler</code>接口，再定义一套实现：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IHttpHandler</span>&#123;</span><br><span class="line">    <span class="function">Task <span class="title">Handle</span>(<span class="params">HttpContext context</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者采用更灵活的方式，采用委托类型，实现相同效果：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> Task <span class="title">RequestDelegate</span>(<span class="params">HttpContext context</span>)</span>;</span><br></pre></td></tr></table></figure><h5 id="2-3-2-Middleware"><a href="#2-3-2-Middleware" class="headerlink" title="2.3.2 Middleware"></a>2.3.2 Middleware</h5><p>中间件是被用到管道<code>(Pipeline)</code>上来处理请求<code>(Request)</code>和响应<code>(Response)</code>的,他将多个中间件连接，当前中间件在完成了自身的请求处理任务之后，需要将请求分发给后续中间件进行处理。也就是说，中间件的输入和输出都可以用<code>Handler</code>对象来表示，所以我们定义中间件为：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RequestDelegate <span class="title">Middleware</span>(<span class="params">RequestDelegate next</span>)</span>;</span><br></pre></td></tr></table></figure><p>即</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;RequestDelegate, RequestDelegate&gt;</span><br></pre></td></tr></table></figure><p>我们可以设计一系列这样的中间件，按顺序执行这些处理程序。</p><h5 id="2-3-3-ApplicationBuilder"><a href="#2-3-3-ApplicationBuilder" class="headerlink" title="2.3.3 ApplicationBuilder"></a>2.3.3 ApplicationBuilder</h5><p>接下来的问题是，我们要如何管理这些中间件，并且如何使用这些中间件呢？使用建造者模式来设计这个管理器，定义<code>ApplicationBuilder</code>,那么应该构建一个<code>Application</code>。对于这个<code>Application</code>，可以这样理解为<br><code>Pipeline = Server + HttpHandler</code><br>用来处理请求的<code>HttpHandler</code>就承载了当前应用的所有职责，那么<code>HttpHandler</code>就等于<code>Application</code>，由于<code>HttpHandler</code>通过<code>RequestDelegate</code>表示，那么由<code>ApplicationBuilder</code>构建的<code>Application</code>就是一个<code>RequestDelegate</code>对象。由于表示<code>HttpHandler</code>的<code>RequestDelegate</code>是由注册的中间件来构建的，所以<code>ApplicationBuilder</code>还具有注册中间件的功能。</p><p><code>ApplicationBuilder.cs</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IApplicationBuilder</span> &#123;</span><br><span class="line">    <span class="function">IApplicationBuilder <span class="title">Use</span>(<span class="params">Func&lt;RequestDelegate, RequestDelegate&gt; middleware</span>)</span>;</span><br><span class="line">    <span class="function">RequestDelegate <span class="title">Build</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ApplicationBuilder</span> : <span class="title">IApplicationBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> List&lt;Func&lt;RequestDelegate, RequestDelegate&gt;&gt; _middlewares = <span class="keyword">new</span> List&lt;Func&lt;RequestDelegate, RequestDelegate&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RequestDelegate <span class="title">Build</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        _middlewares.Reverse();</span><br><span class="line">        <span class="keyword">return</span> httpContext =&gt; &#123;</span><br><span class="line">            RequestDelegate next = _ =&gt; &#123; _.Response.StatusCode = <span class="number">404</span>; <span class="keyword">return</span> Task.CompletedTask; &#125;;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> middleware <span class="keyword">in</span> _middlewares) &#123;</span><br><span class="line">                next = middleware(next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> next(httpContext);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IApplicationBuilder <span class="title">Use</span>(<span class="params">Func&lt;RequestDelegate, RequestDelegate&gt; middleware</span>)</span> &#123;</span><br><span class="line">        _middlewares.Add(middleware);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改<code>Program</code>类，增加定义三个中间件：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestDelegate <span class="title">FooMiddleware</span>(<span class="params">RequestDelegate next</span>)</span></span><br><span class="line"><span class="function"></span>=&gt; <span class="keyword">async</span> context =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">"Foo=&gt;"</span>);</span><br><span class="line">    <span class="keyword">await</span> next(context);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestDelegate <span class="title">BarMiddleware</span>(<span class="params">RequestDelegate next</span>)</span></span><br><span class="line"><span class="function"></span>=&gt; <span class="keyword">async</span> context =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">"Bar=&gt;"</span>);</span><br><span class="line">    <span class="keyword">await</span> next(context);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestDelegate <span class="title">BazMiddleware</span>(<span class="params">RequestDelegate next</span>)</span></span><br><span class="line"><span class="function"></span>=&gt; context =&gt; context.Response.WriteAsync(<span class="string">"Baz"</span>);</span><br></pre></td></tr></table></figure><p>修改下程序入口<code>Main</code>方法，测试运行：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span> &#123;   </span><br><span class="line">    IServer server = <span class="keyword">new</span> HttpListenerServer();   </span><br><span class="line">    <span class="keyword">var</span> application = <span class="keyword">new</span> ApplicationBuilder()</span><br><span class="line">        .Use(FooMiddleware)</span><br><span class="line">        .Use(BarMiddleware)</span><br><span class="line">        .Use(BazMiddleware)</span><br><span class="line">        .Build();              </span><br><span class="line">    <span class="keyword">await</span> server.StartAsync(application);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:<br><img src="/blog_images/aspnet_core_mini/main2.png" alt="main2"></p><h5 id="2-3-4-WebHost"><a href="#2-3-4-WebHost" class="headerlink" title="2.3.4 WebHost"></a>2.3.4 WebHost</h5><p>管理服务器及后续的管道构建，需要一个应用宿主<code>WebHost</code>,管道在<code>WebHost</code>对象启动的时候就被构建出来了。<code>WebHost</code>只做了一件事，将我们构造的中间件管道处理器在指定<code>Server</code>运行起来。<br><code>WebHost.cs</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IWebHost</span> &#123;</span><br><span class="line">    <span class="function">Task <span class="title">StartAsync</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WebHost</span> : <span class="title">IWebHost</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IServer _server;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> RequestDelegate _handler;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WebHost</span>(<span class="params">IServer server, RequestDelegate handler</span>)</span> &#123;</span><br><span class="line">        _server = server;</span><br><span class="line">        _handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task <span class="title">StartAsync</span>(<span class="params"></span>)</span> =&gt; _server.StartAsync(_handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要构建<code>WebHost</code>，需要知道用哪个服务器，和配置了哪些中间件，<code>WebHostBuilder</code>就是创建作为应用宿主的<code>WebHost</code>。<br><code>WebHostBuilder.cs</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IWebHostBuilder</span> &#123;</span><br><span class="line">    <span class="function">IWebHostBuilder <span class="title">UseServer</span>(<span class="params">IServer server</span>)</span>;</span><br><span class="line">    <span class="function">IWebHostBuilder <span class="title">Configure</span>(<span class="params">Action&lt;IApplicationBuilder&gt; configure</span>)</span>;</span><br><span class="line">    <span class="function">IWebHost <span class="title">Build</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WebHostBuilder</span> :<span class="title">IWebHostBuilder</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IServer _server;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> List&lt;Action&lt;IApplicationBuilder&gt;&gt; _configures = <span class="keyword">new</span> List&lt;Action&lt;IApplicationBuilder&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IWebHostBuilder <span class="title">Configure</span>(<span class="params">Action&lt;IApplicationBuilder&gt; configure</span>)</span> &#123;</span><br><span class="line">        _configures.Add(configure);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IWebHostBuilder <span class="title">UseServer</span>(<span class="params">IServer server</span>)</span> &#123;</span><br><span class="line">        _server = server;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IWebHost <span class="title">Build</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> builder = <span class="keyword">new</span> ApplicationBuilder();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> configure <span class="keyword">in</span> _configures) &#123;</span><br><span class="line">            configure(builder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebHost(_server, builder.Build());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给<code>IWebHostBuilder</code>加一个扩展方法,用来使用<code>HttpListenerServer</code> 服务器,修改<code>HttpListenerServer.cs</code>，增加：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Extensions</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IWebHostBuilder <span class="title">UseHttpListener</span>(<span class="params"><span class="keyword">this</span> IWebHostBuilder builder, <span class="keyword">params</span> <span class="keyword">string</span>[] urls</span>)</span></span><br><span class="line"><span class="function"></span>    =&gt; builder.UseServer(<span class="keyword">new</span> HttpListenerServer(urls));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后修改<code>Main</code>启动方法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span> &#123;   </span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> WebHostBuilder()</span><br><span class="line">        .UseHttpListener()</span><br><span class="line">        .Configure(app =&gt; app</span><br><span class="line">            .Use(FooMiddleware)</span><br><span class="line">            .Use(BarMiddleware)</span><br><span class="line">            .Use(BazMiddleware))</span><br><span class="line">        .Build()</span><br><span class="line">        .StartAsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:<br><img src="/blog_images/aspnet_core_mini/main2.png" alt="main2"></p><p><strong>注：在<code>ASP.NET Core 3.0</code>后，舍弃了<code>WebHost</code>的构建，采用泛型主机<code>(Generic Hosting)</code>来构建宿主。</strong></p>]]></content>
      
      
      <categories>
          
          <category> .Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> .Net </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>debian下部署文件共享程序samba</title>
      <link href="/articles/office/debian-samba/"/>
      <url>/articles/office/debian-samba/</url>
      
        <content type="html"><![CDATA[<hr><p>Samba是在Linux和UNIX系统上实现SMB协议的一个免费软件，由服务器及客户端程序构成。SMB（Server Messages Block，信息服务块）是一种在局域网上共享文件和打印机的一种通信协议，它为局域网内的不同计算机之间提供文件及打印机等资源的共享服务。SMB协议是客户机/服务器型协议，客户机通过该协议可以访问服务器上的共享文件系统、打印机及其他资源。通过设置“NetBIOS over TCP/IP”使得Samba不但能与局域网络主机分享资源，还能与全世界的电脑分享资源。</p><a id="more"></a><h3 id="1-安装samba程序"><a href="#1-安装samba程序" class="headerlink" title="1. 安装samba程序"></a>1. 安装samba程序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt -y update</span><br><span class="line">$ sudo apt -y upgrade</span><br><span class="line">$ sudo apt install samba</span><br></pre></td></tr></table></figure><p>在弹出的确认界面中，如果你使用的是静态IP地址，请在使用DHCP的WINS设置时回答否，即NO。<br><img src="/blog_images/debian_samba/1.png" alt="set"></p><h3 id="2-配置共享"><a href="#2-配置共享" class="headerlink" title="2. 配置共享"></a>2. 配置共享</h3><p>安装软件包后，继续执行下面步骤，将执行配置并管理Samba服务：</p><h4 id="2-1-建立共享目录"><a href="#2-1-建立共享目录" class="headerlink" title="2.1 建立共享目录"></a>2.1 建立共享目录</h4><p>新建一个共享目录，设置目录权限（所有用户可读写，一般不推荐)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mkdir /home/share</span><br><span class="line">$ sudo chmod 0777 /home/share</span><br></pre></td></tr></table></figure><h4 id="2-2-修改配置文件"><a href="#2-2-修改配置文件" class="headerlink" title="2.2 修改配置文件"></a>2.2 修改配置文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim /etc/samba/smb.conf</span><br></pre></td></tr></table></figure><p>在文档尾部追加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[share]</span><br><span class="line">path = /home/share</span><br><span class="line">available = yes</span><br><span class="line">browseable = yes</span><br><span class="line">writable = yes</span><br><span class="line">public = yes</span><br><span class="line">create mask = 0777</span><br><span class="line">valid users = user1</span><br></pre></td></tr></table></figure><p>检查语法：如果没有问题则有一句：<code>Loaded services file OK.</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo testparm</span><br></pre></td></tr></table></figure><h4 id="2-3-添加samba用户"><a href="#2-3-添加samba用户" class="headerlink" title="2.3 添加samba用户"></a>2.3 添加samba用户</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># smbpasswd -a user1</span></span><br></pre></td></tr></table></figure><p>根据提示设置密码。</p><p>配置完成后重新启动<code>samba</code>守护程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart smbd nmbd</span><br></pre></td></tr></table></figure><p>查看状态:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl status smbd</span><br></pre></td></tr></table></figure><p><img src="/blog_images/debian_samba/2.png" alt="check"></p>]]></content>
      
      
      <categories>
          
          <category> Office </category>
          
      </categories>
      
      
        <tags>
            
            <tag> samba </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Win10下部署VSCode的Rust开发环境</title>
      <link href="/articles/dev/rust-config/"/>
      <url>/articles/dev/rust-config/</url>
      
        <content type="html"><![CDATA[<hr><p>Rust是一门系统编程语言,专注于安全,尤其是并发安全，支持函数式和命令式以及泛型等编程范式的多范式语言。在一定意义上来说，可以和C++竞争。虽然发展迅速，但由于语言相对较新，各方面资料较少,本人在win10下部署VSCode的Rust环境时遇到各种问题，最后终于搭建起来了，现把步骤记录一下。</p><a id="more"></a><h3 id="1-安装-C-build-tools"><a href="#1-安装-C-build-tools" class="headerlink" title="1. 安装 C++ build tools"></a>1. 安装 C++ build tools</h3><p>在Windows环境下开发rust，一般都用微软的C++ build tools,可以安装最新的Microsoft Visual C++ Build Tools 2019，如果没有安装Visual Studio,可以只安装Visual C++ Build Tools。</p><h4 id="1-1-下载C-build-tools"><a href="#1-1-下载C-build-tools" class="headerlink" title="1.1 下载C++ build tools"></a>1.1 下载C++ build tools</h4><p>下载地址：<a href="https://visualstudio.microsoft.com/zh-hans/downloads/" target="_blank" rel="noopener">https://visualstudio.microsoft.com/zh-hans/downloads/</a><br>拉到下面的“所有下载”，找到“Visual Studio 2019工具”，下载工具安装程序。<br><img src="/blog_images/rust_config/1.png" alt="vstool"></p><h4 id="1-2-安装-vs-buildtools"><a href="#1-2-安装-vs-buildtools" class="headerlink" title="1.2 安装 vs_buildtools"></a>1.2 安装 vs_buildtools</h4><p>运行下载下来的exe程序，选择界面中的“工作负载”标签页的“C++生成工具”<br><img src="/blog_images/rust_config/2.jpg" alt="vstoolsetup"></p><h3 id="2-下载安装Rust开发工具包-rustup-init-exe"><a href="#2-下载安装Rust开发工具包-rustup-init-exe" class="headerlink" title="2. 下载安装Rust开发工具包 rustup-init.exe"></a>2. 下载安装Rust开发工具包 rustup-init.exe</h3><p>官方地址：<a href="https://www.rust-lang.org/" target="_blank" rel="noopener">https://www.rust-lang.org/</a><br><code>rustup-init.exe</code> 是rust 开发环境的初始工具包，可以通过该工具软件下载<code>rustup</code>和<code>cargo</code>。<br>运行<code>rustup-init.exe</code> 后，显示如下<br><img src="/blog_images/rust_config/rust1.png" alt="rustinit"><br>默认会安装到当前用户下,该软件默认检查环境变量<code>CARGO_HOME</code>、<code>RUSTUP_HOME</code>，分别为<code>.cargo</code>、<code>.rustup</code>设置目录，按需修改（需要注意的是后期包的累积可能会占用巨量的存储空间）。<br>一般默认安装即可，默认的<code>default host triple</code>是<code>x86_64-pc-windows-msvc</code>,如果需要用<code>GDB</code>作为调试器，则要选择自定义安装，将<code>default host triple</code>改为<code>x86_64-pc-windows-gnu</code>。<code>default toolchain</code>选择<code>stable</code>，实际我们在配置vscode的环境的时候需要用到<code>nightly</code>版本。下载安装完成后，输入命令，检查安装是否成功：正确输出版本信息则表示安装成功。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; rustup --version</span><br><span class="line">rustup <span class="number">1</span>.<span class="number">20</span>.<span class="number">2</span> (<span class="number">13979</span>c968 <span class="number">2019</span>-<span class="number">10</span>-<span class="number">16</span>)</span><br><span class="line">&gt; cargo --version</span><br><span class="line">cargo <span class="number">1</span>.<span class="number">39</span>.<span class="number">0</span> (<span class="number">1</span>c6ec66d5 <span class="number">2019</span>-<span class="number">09</span>-<span class="number">30</span>)</span><br></pre></td></tr></table></figure><p>如果需要安装nightly版本,并设置nightly为默认Rust环境，则运行：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; rustup install nightly</span><br><span class="line">&gt; rustup<span class="built_in"> default </span>nightly</span><br></pre></td></tr></table></figure><p>更新所有rust:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; rustup update</span></span><br></pre></td></tr></table></figure><p>检查rustup工具是否需要更新</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; rustup <span class="keyword">self </span>update</span><br></pre></td></tr></table></figure><p>卸载rustup</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; rustup <span class="keyword">self </span>uninstall</span><br></pre></td></tr></table></figure><p>Rust 所有工具链都被安装在了 ~/.rustup/toolchains/ 目录下面。如果你需要配置可以在这里面找。</p><h4 id="2-1-setting-toml-配置文件说明"><a href="#2-1-setting-toml-配置文件说明" class="headerlink" title="2.1 setting.toml 配置文件说明"></a>2.1 setting.toml 配置文件说明</h4><p>该文件位于<code>.rustup</code>目录下。</p><ul><li><code>default_host_triple</code>:对该文件进行修改以改变默认值。</li><li><code>default_toolchain</code>:默认使用的工具链，可由<code>rustup default &lt;toolchain name&gt;</code>进行修改。</li></ul><h4 id="2-2-rustup命令"><a href="#2-2-rustup命令" class="headerlink" title="2.2 rustup命令"></a>2.2 rustup命令</h4><ul><li><code>rustup show</code>:列出现在使用的和已安装的rust版本。</li><li><code>rustup update</code>:更新所有已安装版本，由于nightly是每日更新，可能会有bug，所以应谨慎。</li><li><code>rustup default</code>:设置将要使用的版本。</li><li><code>rustup component &lt;sub&gt;</code>:列出(list)、安装(add)、移除(remove)组件。<br>例如：通过rustup获取最新源码：<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; rustup component add rust-src</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-国内加速"><a href="#3-国内加速" class="headerlink" title="3. 国内加速"></a>3. 国内加速</h3><p>由于众所周知的原因，国内速度会很慢，所以可以使用国内镜像来加速。<br>这里列出科大源，修改环境变量如下，同时加速<code>cargo</code>和<code>rust</code>：</p><ul><li><code>RUSTUP_DIST_SERVER</code>:<a href="https://mirrors.ustc.edu.cn/rust-static" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/rust-static</a></li><li><code>RUSTUP_UPDATE_ROOT</code>:<a href="https://mirrors.ustc.edu.cn/rust-static/rustup" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/rust-static/rustup</a></li></ul><h3 id="4-Racer"><a href="#4-Racer" class="headerlink" title="4. Racer"></a>4. Racer</h3><p>racer是一个由rust的爱好者提供的rust自动补全和语法分析工具，被用来提供基本的补全功能和定义跳转功能。其本身完全由rust写成，补全功能已经比较完善了。如下有2种安装方式：</p><h4 id="4-1-自动安装"><a href="#4-1-自动安装" class="headerlink" title="4.1 自动安装"></a>4.1 自动安装</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; cargo install racer</span><br></pre></td></tr></table></figure><p>在安装过程中会出错，提示需要使用nightly版本的rust支持，则安装nightly版本的rust</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; rustup <span class="keyword">install</span> nightly</span><br><span class="line">&gt; cargo +nightly <span class="keyword">install</span> racer</span><br></pre></td></tr></table></figure><h4 id="4-2-编译安装"><a href="#4-2-编译安装" class="headerlink" title="4.2 编译安装"></a>4.2 编译安装</h4><p>首先，下载源码：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; git <span class="keyword">clone</span> <span class="title">https</span>://github.com/phildawes/racer.git</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">cd</span> racer </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> cargo build --release</span></span><br></pre></td></tr></table></figure><p>编译好后其生成的二进制文件在目录<code>target/release/racer</code>下。<br>设置rust源码环境变量：<code>RUST_SRC_PATH</code>。<br>测试安装结果：<br>linux 下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./target/release/racer complete std::io::B</span><br></pre></td></tr></table></figure><p>windows 下</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; target\release\racer complete std::io::B</span><br></pre></td></tr></table></figure><p>将会看到racer的提示，这表示racer已经执行完成了。</p><h3 id="5-安装rustfmt格式化工具"><a href="#5-安装rustfmt格式化工具" class="headerlink" title="5. 安装rustfmt格式化工具"></a>5. 安装rustfmt格式化工具</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo install rustfmt</span><br></pre></td></tr></table></figure><h3 id="6-集成VS-Code编辑器"><a href="#6-集成VS-Code编辑器" class="headerlink" title="6. 集成VS Code编辑器"></a>6. 集成VS Code编辑器</h3><h4 id="6-1-设置环境变量"><a href="#6-1-设置环境变量" class="headerlink" title="6.1 设置环境变量"></a>6.1 设置环境变量</h4><table><thead><tr><th align="left">环境变量</th><th align="left">默认值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">RUSTUP_HOME</td><td align="left">~/.rustup 或 %USERPROFILE%/.rustup</td><td align="left">rustup 的主目录，保存工具链和配置文件的地方。</td></tr><tr><td align="left">CARGO_HOME</td><td align="left">~/.cargo 或 %USERPROFILE%/.cargo</td><td align="left">Cargo 的主目录。</td></tr><tr><td align="left">RUSTUP_TOOLCHAIN</td><td align="left"></td><td align="left">如果设置了，会覆盖所有 rust 工具调用的工具链，必须是已安装的工具链的名字，否则会调用失败。</td></tr><tr><td align="left">RUSTUP_DIST_SERVER</td><td align="left"><a href="https://static.rust-lang.org" target="_blank" rel="noopener">https://static.rust-lang.org</a></td><td align="left">设置静态资源的下载源。速度慢可以改为国内镜像。</td></tr><tr><td align="left">RUSTUP_UPDATE_ROOT</td><td align="left"><a href="https://static.rust-lang.org/rustup" target="_blank" rel="noopener">https://static.rust-lang.org/rustup</a></td><td align="left">更新源，速度慢可以改为国内镜像。</td></tr><tr><td align="left">RUST_SRC_PATH</td><td align="left">~/.multirust/toolchains/[your-toolchain]/lib/rustlib/src/rust/src</td><td align="left">rust源码，用于racer进行代码补全</td></tr></tbody></table><h4 id="6-2-安装VS-Code编辑器"><a href="#6-2-安装VS-Code编辑器" class="headerlink" title="6.2 安装VS Code编辑器"></a>6.2 安装VS Code编辑器</h4><p>官方地址：<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">https://code.visualstudio.com/</a><br>安装完成后需要安装扩展插件。</p><h5 id="6-2-1-安装插件"><a href="#6-2-1-安装插件" class="headerlink" title="6.2.1 安装插件"></a>6.2.1 安装插件</h5><p>Windows平台：<a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools" target="_blank" rel="noopener">C/C++(Windows)</a><br>Linux/OSX平台：<a href="https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb" target="_blank" rel="noopener">CodeLLDB</a><br>包管理插件：<a href="https://marketplace.visualstudio.com/items?itemName=serayuzgur.crates" target="_blank" rel="noopener">crates</a><br>Rust-lang扩展：<a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust" target="_blank" rel="noopener">Rust(rls)</a>，可以为很多IDE或编辑器提供包括不限于自动补全、跳转定义、重命名、跳转类型的功能支持。<br>因为前面安装的C++是<code>Microsoft Visual C++ Build Tools 2019</code>，所以我们不需要安装CodeLLDB。</p><h3 id="6-3-配置-VS-Code"><a href="#6-3-配置-VS-Code" class="headerlink" title="6.3 配置 VS Code"></a>6.3 配置 VS Code</h3><p>安装好工具后，需要配置调试启动项：单击“调试(Debug)”-&gt;“添加配置(Add Configuration)”,如果是在windows上使用，则选择C/C++(Windows),如果是Linux或者Mac，则选择C/C++(gdb)<br><img src="/blog_images/rust_config/3.jpg" alt="debugconfig1"><br>windows的Microsoft Visual C++ Build Tools调试启动配置launch.json文件如下：<br><img src="/blog_images/rust_config/4.png" alt="debugconfig2"><br>之后编写代码，添加断点，就可以调试了。</p><h3 id="6-4-测试"><a href="#6-4-测试" class="headerlink" title="6.4 测试"></a>6.4 测试</h3><p>使用命令创建 Rust 新项目，之后使用 VSCode 打开项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cargo new hello</span><br><span class="line">code hello</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VirtualBox 修改VDI文件的UUID值</title>
      <link href="/articles/os/virtualbox-uuid/"/>
      <url>/articles/os/virtualbox-uuid/</url>
      
        <content type="html"><![CDATA[<hr><p>在使用virtualBox虚拟机的过程中，我们经常会对同一个镜像文件来做多个Host的实例，但是注册该镜像的时候会报错：”UUID {XXXXXXXXXXXXXX} already exists”。下面我们给出VirtualBox修改UUID的方法。</p><a id="more"></a><h3 id="使用VirtualBox工具VBoxManage-exe修改"><a href="#使用VirtualBox工具VBoxManage-exe修改" class="headerlink" title="使用VirtualBox工具VBoxManage.exe修改"></a>使用VirtualBox工具VBoxManage.exe修改</h3><p>可以使用命令行工具VBoxManage.exe来实现修改VID文件的UUID值：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Windows</span>\<span class="title">system32</span>&gt;<span class="title">cd</span> <span class="title">D</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Oracle</span>\<span class="title">VirtualBox</span></span></span><br><span class="line"><span class="function"><span class="title">D</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Oracle</span>\<span class="title">VirtualBox</span>&gt;<span class="title">VBoxManage.exe</span> <span class="title">internalcommands</span> <span class="title">sethduuid</span> "<span class="title">D</span>:\<span class="title">VM</span>\<span class="title">Win10dev.vdi</span>"</span></span><br><span class="line"><span class="function"><span class="title">UUID</span> <span class="title">changed</span> <span class="title">to</span>: <span class="title">bdce0e02</span>-16<span class="title">b2</span>-4<span class="title">bfd</span>-82<span class="title">ca</span>-9<span class="title">cf5842b9829</span></span></span><br></pre></td></tr></table></figure><p>执行完成之后就改变了该vdi文件的uuid值，可以重新注册导入了。</p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> virtualbox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Chrome浏览器，Win10系统右下角弹广告处理</title>
      <link href="/articles/others/remove-ad/"/>
      <url>/articles/others/remove-ad/</url>
      
        <content type="html"><![CDATA[<hr><p>&emsp;&emsp;突然发现自己的系统右下角时不时的弹出各种广告，进程找了半天也没发现问题，终于有网友指出是通过Chrome来进行这个骚操作的，可恶至极，记录下如何关闭这些网站的推送。</p><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;常规思路，如果认为是本地安装的软件，用工具和杀毒软件其实得不到解决的，因为这些广告是通过Chrome浏览器来推送的。<br>&emsp;&emsp;解决办法是设置中移除这些非授权网站</p><h3 id="打开设置"><a href="#打开设置" class="headerlink" title="打开设置"></a>打开设置</h3><p>点击浏览器右上角三个点进入设置页面。<br><img src="/blog_images/remove_ad/1.png" alt="set"></p><h3 id="网站设置"><a href="#网站设置" class="headerlink" title="网站设置"></a>网站设置</h3><p>点开”高级”，拉到下面找到”网站设置”<br><img src="/blog_images/remove_ad/2.png" alt="webset"></p><h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><p>点开网站设置，找到”通知”<br><img src="/blog_images/remove_ad/3.png" alt="notice"><br>删除允许栏目里的网站，就不会再推送这些网站的通知了<br><img src="/blog_images/remove_ad/4.png" alt="notice2"></p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> win10 </tag>
            
            <tag> chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C# lambda表达式</title>
      <link href="/articles/dev/cslambda/"/>
      <url>/articles/dev/cslambda/</url>
      
        <content type="html"><![CDATA[<hr><p>在C#中经常用到委托，其经过进化演变，到C#3.0后引入了lambda表达式，这种表达式与匿名方法的概念类似，但更具表现力并且更简练。 这两个功能统称为匿名函数。<br>参考：<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/statements-expressions-operators/anonymous-functions" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/statements-expressions-operators/anonymous-functions</a></p><a id="more"></a><h3 id="lambda表达式定义"><a href="#lambda表达式定义" class="headerlink" title="lambda表达式定义"></a>lambda表达式定义</h3><p>“<code>Lambda</code> 表达式”<code>(lambda expression)</code>是一个匿名函数，可以表示为委托的代码，或者表示为表达式树的代码，它所表示的表达式树可以编译为委托。 <code>Lambda</code>表达式的特定委托类型取决于其参数和返回值。不返回值的<code>Lambda</code>表达式对应于<code>Action</code>委托，具体取决于其参数数量。 返回值的<code>Lambda</code>表达式对应于<code>Func</code>委托，具体取决于其参数数量。</p><p><code>Lambda</code> 表达式广泛用于：</p><ul><li>将要执行的代码传递给异步方法，例如 <code>Task.Run(Action)</code>。</li><li>编写<code>LINQ</code>查询表达式。</li><li>创建表达式树。</li></ul><h3 id="lambda表达式两种形式"><a href="#lambda表达式两种形式" class="headerlink" title="lambda表达式两种形式"></a>lambda表达式两种形式</h3><p>表达式<code>lambda</code>，表达式为其主体：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(input-parameters) =&gt; expression</span><br></pre></td></tr></table></figure><p>语句<code>lambda</code>，语句块作为其主体：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(input-parameters) =&gt; &#123; &lt;sequence-of-statements&gt; &#125;</span><br></pre></td></tr></table></figure><h3 id="C-中委托的演变"><a href="#C-中委托的演变" class="headerlink" title="C#中委托的演变"></a>C#中委托的演变</h3><p>C#1.0</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LambdaDemo</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">string</span> <span class="title">MessageHandler</span>(<span class="params"><span class="keyword">string</span> p, <span class="keyword">string</span> msg</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">string</span> <span class="title">ShowMessage</span>(<span class="params"><span class="keyword">string</span> p, <span class="keyword">string</span> msg</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">$"<span class="subst">&#123;p&#125;</span> says <span class="subst">&#123;msg&#125;</span>"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">LambdaTest1</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        MessageHandler handler = <span class="keyword">new</span> MessageHandler(ShowMessage);</span><br><span class="line">        <span class="keyword">string</span> m = handler(<span class="string">"Tom1"</span>, <span class="string">"Hello!"</span>);</span><br><span class="line">        Console.WriteLine(m);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">$"LambdaTest1.Value=<span class="subst">&#123;m&#125;</span>"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C#2.0</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LambdaDemo</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">string</span> <span class="title">MessageHandler</span>(<span class="params"><span class="keyword">string</span> p, <span class="keyword">string</span> msg</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">LambdaTest2</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        MessageHandler handler = <span class="keyword">delegate</span> (<span class="keyword">string</span> p, <span class="keyword">string</span> msg) &#123; <span class="keyword">return</span> <span class="string">$"<span class="subst">&#123;p&#125;</span> says <span class="subst">&#123;msg&#125;</span>"</span>; &#125;;</span><br><span class="line">        <span class="keyword">string</span> m = handler(<span class="string">"Tom2"</span>, <span class="string">"Hello!"</span>);</span><br><span class="line">        Console.WriteLine(m);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">$"LambdaTest2.Value=<span class="subst">&#123;m&#125;</span>"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C#3.0</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LambdaDemo</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">string</span> <span class="title">MessageHandler</span>(<span class="params"><span class="keyword">string</span> p, <span class="keyword">string</span> msg</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">LambdaTest3</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        MessageHandler handler = (p, msg) =&gt; &#123; <span class="keyword">return</span> <span class="string">$"<span class="subst">&#123;p&#125;</span> says <span class="subst">&#123;msg&#125;</span>"</span>; &#125;;</span><br><span class="line">        <span class="comment">//MessageHandler handler = (p, msg) =&gt; $"&#123;p&#125; says &#123;msg&#125;";</span></span><br><span class="line">        <span class="keyword">string</span> m = handler(<span class="string">"Tom3"</span>, <span class="string">"Hello!"</span>);</span><br><span class="line">        Console.WriteLine(m);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">$"LambdaTest3.Value=<span class="subst">&#123;m&#125;</span>"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上3种写法都是等效的。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LambdaDemo</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> MessageHandler <span class="title">CreateHandler1</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">delegate</span> (<span class="keyword">string</span> p, <span class="keyword">string</span> msg) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">$"<span class="subst">&#123;p&#125;</span> says <span class="subst">&#123;msg&#125;</span>"</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> MessageHandler <span class="title">CreateHandler2</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (p, msg) =&gt; <span class="string">$"<span class="subst">&#123;p&#125;</span> says <span class="subst">&#123;msg&#125;</span>"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> MessageHandler <span class="title">CreateHandler3</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        =&gt; (p, msg) =&gt; <span class="string">$"<span class="subst">&#123;p&#125;</span> says <span class="subst">&#123;msg&#125;</span>"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">LambdaTest4</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        MessageHandler handler = CreateHandler3();</span><br><span class="line">        <span class="keyword">string</span> m = handler(<span class="string">"Tom4"</span>, <span class="string">"Hello!"</span>);</span><br><span class="line">        Console.WriteLine(m);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">$"LambdaTest4.Value=<span class="subst">&#123;m&#125;</span>"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，以上<code>CreateHandler1</code>、<code>CreateHandler2</code>、<code>CreateHandler3</code>是等效的。 <code>C#</code>的<code>Lambda</code> 表达式都使用<code>Lambda</code>运算符<code>=&gt;</code>，该运算符读为“<code>goes to</code>”， 若要创建<code>Lambda</code>表达式，需要在<code>lambda</code>运算符左侧指定输入参数（如果有），然后在另一侧输入表达式或语句块。 例如，单行<code>Lambda</code>表达式<code>(p, msg) =&gt; $&quot;{p} says {msg}&quot;;</code>指定名为 <code>p,msg</code> 的参数并返回组合字符串。</p>]]></content>
      
      
      <categories>
          
          <category> .Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Visual Studio 配置注视模板</title>
      <link href="/articles/dev/vsconfig/"/>
      <url>/articles/dev/vsconfig/</url>
      
        <content type="html"><![CDATA[<hr><p>用 VS 开发程序的时候，我们往往需要个性化自己的注释，而这些注释是可以模板化的。下面就是具体配置我们的注释模板。</p><a id="more"></a><p>我们以VS2017/VS2019为例子来进行相应配置。<br>在路径<br><code>C:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise\Common7\IDE\ItemTemplates\CSharp\Code\2052</code> 下有名为 <code>Class</code>、<code>CodeFile</code>、<code>Interface</code>、<code>WebClass</code>几个文件夹，分别修改文件夹中的 <code>.cs</code>文件，添加自己的注释信息：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#region &lt;&lt; 版 本 注 释 &gt;&gt;</span><br><span class="line">/**</span><br><span class="line"> *【功 能】</span><br><span class="line"> *  </span><br><span class="line"> *  </span><br><span class="line"> *   版本       变更时间        部门        作者             变更内容</span><br><span class="line"> * ─────────────────────────────────────────────────────────────────</span><br><span class="line"> *   V1.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>   $<span class="built_in">time</span>$              $username$       </span><br><span class="line"> *</span><br><span class="line"> * Copyright (c)  $registeredorganization$ $year$. All Rights Reserved.</span><br><span class="line"> */</span><br><span class="line">#endregion</span><br></pre></td></tr></table></figure><p>附：注释模版本中的参数说明：</p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">clrversion</td><td align="left">当前系统CLR版本号</td></tr><tr><td align="left">guid [1-10]</td><td align="left">生成全局唯一标识符,可以生成10个 (例如:guid1)</td></tr><tr><td align="left">itemname</td><td align="left">设置容器CPU权重，在CPU共享场景使用</td></tr><tr><td align="left">machinename</td><td align="left">当前机器的名称</td></tr><tr><td align="left">registeredorganization</td><td align="left">注册的公司名称</td></tr><tr><td align="left">rootnamespace</td><td align="left">命名空间</td></tr><tr><td align="left">safeitemname</td><td align="left">保存的文件名</td></tr><tr><td align="left">time</td><td align="left">当前系统时间,格式:DD/MM/YYYY 00:00:00.</td></tr><tr><td align="left">usernamnam</td><td align="left">用户名</td></tr><tr><td align="left">userdomain</td><td align="left">用户所在的域</td></tr><tr><td align="left">year</td><td align="left">当前系统时间 YYYY</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> visual studio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>压缩虚拟机VirtualBox 文件</title>
      <link href="/articles/os/virtualbox-compact/"/>
      <url>/articles/os/virtualbox-compact/</url>
      
        <content type="html"><![CDATA[<hr><p>随着virtualbox虚拟机的使用，虚拟机文件会越来越大，因为虚拟机磁盘文件不会因为虚拟机空间的释放而减少，这个时候需要我们手工来处理。</p><a id="more"></a><ol><li><p>虚拟机为<code>Windows</code>系统<br>如果虚拟机为Windows,则首先需要从微软官网下载SDelete工具<a href="https://technet.microsoft.com/en-us/sysinternals/bb897443" target="_blank" rel="noopener">https://technet.microsoft.com/en-us/sysinternals/bb897443</a>,我们将下载的文件解压缩，放在<code>C:\SDelete</code>路径，然后用管理员权限打开<code>cmd</code>，执行以下命令，命令的意思是把整个C盘下的未使用的磁盘空间标记为0：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; sdelete –z c:\</span><br></pre></td></tr></table></figure></li><li><p>虚拟机为<code>linux</code>系统<br>如果虚拟机为<code>linux</code>系统，则执行以下命令,进行碎片整理，然后删除碎片</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dd <span class="keyword">if</span>=/dev/zero of=zero.fill</span><br><span class="line">$ sudo rm -f zero.fill</span><br></pre></td></tr></table></figure></li><li><p>执行完成后，关闭虚拟。进入宿主机，用管理员权限打开PowerShell,切换到<code>VirtualBox</code>安装目录，执行命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; cd <span class="string">"D:\Program Files\Oracle\VirtualBox"</span></span><br><span class="line">&gt; VBoxManage modifyhd D:\VM\win7.vdi –compact</span><br></pre></td></tr></table></figure><p>执行完后虚拟机文件就会释放未被使用的空间了。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> virtualbox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在debian中搭建kms服务器</title>
      <link href="/articles/os/win-kms/"/>
      <url>/articles/os/win-kms/</url>
      
        <content type="html"><![CDATA[<hr><p>自己搭建一套kms服务器，用于激活vl版本的windows 和 office。</p><a id="more"></a><h3 id="1-下载程序"><a href="#1-下载程序" class="headerlink" title="1. 下载程序"></a>1. 下载程序</h3><p>下载搭建服务的应用程序，地址：<a href="https://github.com/Wind4/vlmcsd/releases" target="_blank" rel="noopener">https://github.com/Wind4/vlmcsd/releases</a><br>下载后，解压缩，在binaries目录下有各种平台的相关程序；找到文件夹 <code>binaries\Linux\intel\glibc\vlmcsd-x64-glibc</code>，具体要根据部署的操作系统的版本，64位则选择 <code>vlmcsd-x64-glibc</code>，32位则选择 <code>vlmcsd-x86-glibc</code>；如果还有其他系统的，则选择相应的文件夹。</p><h3 id="2-部署程序"><a href="#2-部署程序" class="headerlink" title="2. 部署程序"></a>2. 部署程序</h3><p>将程序部署到 <code>/opt/vlmcsd</code>中，没有相应目录，则新建，将 <code>vlmcsd-x64-glibc</code>复制到该目录下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mkdir /opt/vlmcsd</span><br><span class="line">$ sudo cp /share/vlmcsd-x64-glibc /opt/vlmcsd/vlmcsd-x64-glibc</span><br></pre></td></tr></table></figure><p>修改 <code>vlmcsd-x64-glibc</code> 执行权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /opt/vlmcsd</span><br><span class="line">$ sudo chmod u+x vlmcsd-x64-glibc</span><br></pre></td></tr></table></figure><h3 id="3-启动程序"><a href="#3-启动程序" class="headerlink" title="3. 启动程序"></a>3. 启动程序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ./vlmcsd-x64-glibc</span><br></pre></td></tr></table></figure><p>查看进程，是否已经启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux|grep vlmcsd</span><br></pre></td></tr></table></figure><p>如果显示以下内容，则表示启动成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root       549  0.0  0.0   8508   128 ?        Ss   16:05   0:00 ./vlmcsd-x64-glibc</span><br><span class="line">root   563  0.0  0.0  18084   984 pts/0    S+   16:21   0:00 grep vlmcsd-x64-glibc</span><br></pre></td></tr></table></figure><p>如果其他程序占用了端口1688，则会报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Warning: 0.0.0.0:1688: Address already <span class="keyword">in</span> use  </span><br><span class="line">Fatal: Could not listen on any socket</span><br></pre></td></tr></table></figure><p>关闭相应的程序即可。</p><h3 id="4-添加开机自启"><a href="#4-添加开机自启" class="headerlink" title="4.添加开机自启"></a>4.添加开机自启</h3><p>添加开机自启，最简单的方法就是使用<code>rc.local</code>，但是debian9默认没有<code>rc.local</code>文件，需要手动添加，但<code>rc.local</code>服务还是自带的，我们可以查看一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cat /lib/systemd/system/rc-local.service</span><br><span class="line"><span class="comment">#  This file is part of systemd.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  systemd is free software; you can redistribute it and/or modify it</span></span><br><span class="line"><span class="comment">#  under the terms of the GNU Lesser General Public License as published by</span></span><br><span class="line"><span class="comment">#  the Free Software Foundation; either version 2.1 of the License, or</span></span><br><span class="line"><span class="comment">#  (at your option) any later version.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This unit gets pulled automatically into multi-user.target by</span></span><br><span class="line"><span class="comment"># systemd-rc-local-generator if /etc/rc.local is executable.</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=/etc/rc.local Compatibility</span><br><span class="line">ConditionFileIsExecutable=/etc/rc.local</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/etc/rc.local start</span><br><span class="line">TimeoutSec=0</span><br><span class="line">RemainAfterExit=yes</span><br><span class="line">GuessMainPID=no</span><br></pre></td></tr></table></figure><h4 id="4-1-添加rc-local-service"><a href="#4-1-添加rc-local-service" class="headerlink" title="4.1 添加rc-local.service"></a>4.1 添加rc-local.service</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/systemd/system/rc-local.service &lt;&lt;EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=/etc/rc.local</span><br><span class="line">ConditionPathExists=/etc/rc.local</span><br><span class="line"> </span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/etc/rc.local start</span><br><span class="line">TimeoutSec=0</span><br><span class="line">StandardOutput=tty</span><br><span class="line">RemainAfterExit=yes</span><br><span class="line">SysVStartPriority=99</span><br><span class="line"> </span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h4 id="4-2-新建rc-local-文件"><a href="#4-2-新建rc-local-文件" class="headerlink" title="4.2 新建rc.local 文件"></a>4.2 新建rc.local 文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/rc.local &lt;&lt;EOF</span><br><span class="line"><span class="comment">#!/bin/sh -e</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># rc.local</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This script is executed at the end of each multiuser runlevel.</span></span><br><span class="line"><span class="comment"># Make sure that the script will "exit 0" on success or any other</span></span><br><span class="line"><span class="comment"># value on error.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># In order to enable or disable this script just change the execution</span></span><br><span class="line"><span class="comment"># bits.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># By default this script does nothing.</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">exit</span> 0</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h4 id="4-3-添加权限，设置开机启动"><a href="#4-3-添加权限，设置开机启动" class="headerlink" title="4.3 添加权限，设置开机启动"></a>4.3 添加权限，设置开机启动</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /etc/rc.local</span><br><span class="line">systemctl <span class="built_in">enable</span> rc.local</span><br><span class="line">systemctl start rc-local.service</span><br></pre></td></tr></table></figure><p>查看服务状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status rc-local.service</span><br></pre></td></tr></table></figure><p>如果显示 以下信息，包含 <code>Active: active</code>,则表示成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">● rc.local.service - /etc/rc.local</span><br><span class="line">   Loaded: loaded (/etc/systemd/system/rc-local.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (exited) since Tue 2019-02-26 21:24:36 CST; 15s ago</span><br><span class="line">  Process: 542 ExecStart=/etc/rc.local start (code=exited, status=0/SUCCESS)</span><br></pre></td></tr></table></figure><p>好了，将开机执行的脚本放在<code>/etc/rc.local</code> 中<code>exit 0</code> 之前，系统重启，就可以开机自动执行了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在/etc/rc.local中添加脚本</span></span><br><span class="line">/opt/vlmcsd/vlmcsd-x64-glibc -l /var/<span class="built_in">log</span>/vlmcsd-x64-glibc.log &gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><h3 id="5-windows客户端测试"><a href="#5-windows客户端测试" class="headerlink" title="5 windows客户端测试"></a>5 windows客户端测试</h3><p>在下载的程序包中找到<code>\binaries\Windows\intel\vlmcs-Windows-x64.exe</code>,同样，32位系统执行<code>vlmcs-Windows-x86.exe</code>；<br>将当前目录 cd 切换到<code>\binaries\Windows\intel</code>，然后执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vlmcs-Windows-x64.exe -v -l 3 192.168.56.2</span><br></pre></td></tr></table></figure><p>参数说明可以通过 <code>vlmcs-Windows-x64.exe -x</code>命令来查看<br>其中<br>-v 表示 输出详细信息<br>-l 3 表示发送Windows Server 2008 Datacenter的激活请求</p><p>返回结果如下，则表示服务器搭建成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Request Parameters</span><br><span class="line">==================</span><br><span class="line"></span><br><span class="line">Protocol version                : 6.0</span><br><span class="line">Client is a virtual machine     : No</span><br><span class="line">Licensing status                : 2 (OOB grace)</span><br><span class="line">Remaining time (0 = forever)    : 43200 minutes</span><br><span class="line">Application ID                  : 55c92734-d682-4d71-983e-d6ec3f16059f (Windows)</span><br><span class="line">SKU ID (aka Activation ID)      : 34e1ae55-27f8-4950-8877-7a03be5fb181 (Windows Server 2019 Datacenter)</span><br><span class="line">KMS ID (aka KMS counted ID)     : 8449b1fb-f0ea-497a-99ab-66ca96e9a0f5 (Windows Server 2019)</span><br><span class="line">Client machine ID               : 548be75c-e4bd-4479-b164-1675d689874a</span><br><span class="line">Previous client machine ID      : 00000000-0000-0000-0000-000000000000</span><br><span class="line">Client request timestamp (UTC)  : 2019-02-26 14:05:52</span><br><span class="line">Workstation name                : ceo-laptop.borland.me</span><br><span class="line">N count policy (minimum clients): 5</span><br><span class="line"></span><br><span class="line">Connecting to 192.168.56.2:1688 ... successful</span><br><span class="line"></span><br><span class="line">Performing RPC <span class="built_in">bind</span> ...</span><br><span class="line">... NDR64 ... BTFN ... NDR32 ... successful</span><br><span class="line">Sending activation request (KMS V6) 1 of 1</span><br><span class="line"></span><br><span class="line">Response from KMS server</span><br><span class="line">========================</span><br><span class="line"></span><br><span class="line">Size of KMS Response            : 260 (0x104)</span><br><span class="line">Protocol version                : 6.0</span><br><span class="line">KMS host extended PID           : 03612-00206-556-735360-03-1050-14393.0000-2892018</span><br><span class="line">KMS host Hardware ID            : 3A1C049600B60076</span><br><span class="line">Client machine ID               : 548be75c-e4bd-4479-b164-1675d689874a</span><br><span class="line">Client request timestamp (UTC)  : 2019-02-26 14:05:52</span><br><span class="line">KMS host current active clients : 50</span><br><span class="line">Renewal interval policy         : 10080</span><br><span class="line">Activation interval policy      : 120</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows debian </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Excel宏命令去除加密</title>
      <link href="/articles/office/macros/"/>
      <url>/articles/office/macros/</url>
      
        <content type="html"><![CDATA[<hr><p>在工作中，平常用到的Excel宏命令中，通常是被人加密处理过的，无法进行修改，下面给出方法去除加密信息。</p><a id="more"></a><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><ol><li>新建一个Excel文件，Alt+F11调出VBA编辑器，插入–模块,拷贝下面代码后执行。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Sub RemovePassword()</span><br><span class="line">    Dim FileName As String</span><br><span class="line">    FileName = Application.GetOpenFilename(&quot;Excel文件（*.xls &amp; *.xla）,*.xls;*.xla&quot;, , &quot;VBA破解&quot;)</span><br><span class="line">    If FileName = CStr(False) Then</span><br><span class="line">        Exit Sub</span><br><span class="line">    Else</span><br><span class="line">        VBAPassword FileName, False</span><br><span class="line">    End If</span><br><span class="line">End Sub</span><br><span class="line"></span><br><span class="line">&apos;设置VBA编码保护</span><br><span class="line">Sub SetProtect()</span><br><span class="line">    Dim FileName As String</span><br><span class="line">    FileName = Application.GetOpenFilename(&quot;Excel文件（*.xls &amp; *.xla）,*.xls;*.xla&quot;, , &quot;VBA破解&quot;)</span><br><span class="line">    If FileName = CStr(False) Then</span><br><span class="line">        Exit Sub</span><br><span class="line">    Else</span><br><span class="line">        VBAPassword FileName, True</span><br><span class="line">    End If</span><br><span class="line">End Sub</span><br><span class="line"></span><br><span class="line">Private Function VBAPassword(FileName As String, Optional Protect As Boolean = False)</span><br><span class="line">    If Dir(FileName) = &quot;&quot; Then</span><br><span class="line">       Exit Function</span><br><span class="line">    Else</span><br><span class="line">       FileCopy FileName, FileName &amp; &quot;.bak&quot;</span><br><span class="line">    End If</span><br><span class="line">    </span><br><span class="line">    Dim GetData As String * 5</span><br><span class="line">    Open FileName For Binary As #1</span><br><span class="line">    Dim CMGs As Long</span><br><span class="line">    Dim DPBo As Long</span><br><span class="line">    </span><br><span class="line">    For i = 1 To LOF(1)</span><br><span class="line">        Get #1, i, GetData</span><br><span class="line">        If GetData = &quot;CMG=&quot;&quot;&quot; Then CMGs = i</span><br><span class="line">        If GetData = &quot;[Host&quot; Then DPBo = i - 2: Exit For</span><br><span class="line">    Next</span><br><span class="line">    </span><br><span class="line">    If CMGs = 0 Then</span><br><span class="line">       MsgBox &quot;请先对VBA编码设置一个保护密码...&quot;, 32, &quot;提示&quot;</span><br><span class="line">       Exit Function</span><br><span class="line">    End If</span><br><span class="line">    </span><br><span class="line">    If Protect = False Then</span><br><span class="line">       Dim St As String * 2</span><br><span class="line">       Dim s20 As String * 1</span><br><span class="line">       </span><br><span class="line">       &apos;取得一个0D0A十六进制字串</span><br><span class="line">       Get #1, CMGs - 2, St</span><br><span class="line">    </span><br><span class="line">       &apos;取得一个20十六制字串</span><br><span class="line">       Get #1, DPBo + 16, s20</span><br><span class="line">    </span><br><span class="line">       &apos;替换加密部份机码</span><br><span class="line">       For i = CMGs To DPBo Step 2</span><br><span class="line">           Put #1, i, St</span><br><span class="line">       Next</span><br><span class="line">       </span><br><span class="line">       &apos;加入不配对符号</span><br><span class="line">       If (DPBo - CMGs) Mod 2 &lt;&gt; 0 Then</span><br><span class="line">          Put #1, DPBo + 1, s20</span><br><span class="line">       End If</span><br><span class="line">       MsgBox &quot;文件解密成功......&quot;, 32, &quot;提示&quot;</span><br><span class="line">    Else</span><br><span class="line">       Dim MMs As String * 5</span><br><span class="line">       MMs = &quot;DPB=&quot;&quot;&quot;</span><br><span class="line">       Put #1, CMGs, MMs</span><br><span class="line">       MsgBox &quot;对文件特殊加密成功......&quot;, 32, &quot;提示&quot;</span><br><span class="line">    End If</span><br><span class="line">    Close #1</span><br><span class="line">End Function</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Office </category>
          
      </categories>
      
      
        <tags>
            
            <tag> office </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows10 应用软件中使用网络驱动器</title>
      <link href="/articles/os/win-net-driver/"/>
      <url>/articles/os/win-net-driver/</url>
      
        <content type="html"><![CDATA[<hr><p>Windows10中，我们在局域网内使用共享文件夹，建立映射的网络驱动器，有时候需要一些软件去调用网络驱动器内的资源，但是发现在资源管理器能正常打开,应用软件却无法识别，命令行中提示：“系统找不到指定的驱动器.”。这里通过简单的注册表设置，可以实现应用软件的识别。</p><a id="more"></a><ol><li>打开注册表编辑器：Win+R,输入Regedit。</li><li>找到注册表项：HKEY_LOCAL_MACHINE -&gt; SOFTWARE -&gt; Microsoft -&gt; Windows -&gt; CurrentVersion -&gt; Policies -&gt; System<br>在右边添加新项：DWORD(32bit) 名称为：EnableLinkedConnections，修改值为1</li><li>重启</li></ol><p>之后就可以像正常的本地磁盘一样使用了。</p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> win10 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PLSQL Developer 配置Oralce11g连接</title>
      <link href="/articles/database/plsql-config/"/>
      <url>/articles/database/plsql-config/</url>
      
        <content type="html"><![CDATA[<hr><p>PLSQL Developer 12已经支持64位系统，之前的版本因为只有32的程序，所以只能使用32位的Oracle客户端。<br>本示例为PLSQL Developer 12,Oracle版本为11g,目前Oracle官网的instantclient是12了，下载客户端为instantclient_12_2的64位版本。11g之后可以不用安装程序，直接使用这种绿色程序便可。</p><a id="more"></a><h3 id="1-配置环境变量"><a href="#1-配置环境变量" class="headerlink" title="1. 配置环境变量"></a>1. 配置环境变量</h3><p>ORACLE_HOME=D:\instantclient_12_2<br>TNS_ADMIN=D:\instantclient_12_2\NETWORK\ADMIN<br>Oracle主目录下的网络管理文件夹NETWORK、ADMIN没有则手动新建。</p><h3 id="2-设置PLSQL-Developer"><a href="#2-设置PLSQL-Developer" class="headerlink" title="2. 设置PLSQL Developer:"></a>2. 设置PLSQL Developer:</h3><p>2.1. 进入程序，选择Configure(配置)-Preferences(首选项)<br><img src="/blog_images/plsql_config/p1.png" alt="p1"></p><p>2.2. 设置Oracle主目录、OCI库，如果环境变量设置正确，下拉会自动查找到。如果没有，则直接手动输入即可。<br><img src="/blog_images/plsql_config/p2.png" alt="p2"><br>    Oracle主目录：D:\instantclient_12_2<br>    OCI库：D:\instantclient_12_2\oci.dll<br>    确定，保存。退出程序。</p><p>2.3. 启动程序，进入登录界面：<br>数据库等下拉会有TNS_ADMIN里tnsnames.ora配置好的连接名，输入用户名、密码即可登录。<br><img src="/blog_images/plsql_config/p3.png" alt="p3"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracle </tag>
            
            <tag> plsql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker部署gitlab服务器(1)</title>
      <link href="/articles/pm/docker-gitlab1/"/>
      <url>/articles/pm/docker-gitlab1/</url>
      
        <content type="html"><![CDATA[<hr><p><a href="https://about.gitlab.com/" target="_blank" rel="noopener">Gitlab</a>是目前比较好用的Git代码托管工具，本篇主要介绍下采用docker方式部署托管平台的方案。<br>详细文档见 <a href="https://docs.gitlab.com/omnibus/docker/README.html#gitlab-docker-images" target="_blank" rel="noopener">https://docs.gitlab.com/omnibus/docker/README.html#gitlab-docker-images</a></p><a id="more"></a><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>操作系统: Debian8.7 64位<br>Docker官方网站 <a href="https://docs.docker.com/engine/installation/" target="_blank" rel="noopener">https://docs.docker.com/engine/installation/</a> 上有各种环境下的安装指南，可以参考下。这里主要采用 Debian 8 Jessie 来介绍。</p><h4 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h4><p>Debian8 的内核默认为 3.16，满足基本的 Docker 运行条件。但是如果打算使用overlay2 存储层驱动，或某些功能不够稳定希望升级到较新版本的内核，可以添加 backports 源，升级到新版本的内核。<br>由于国内访问国际资源的速度问题，我们采用国内镜像站的资源来作源。<br>执行下面的命令添加 backports 源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"deb http://mirrors.163.com/debian jessie-backports main"</span> | sudo tee /etc/apt/sources.list.d/backports.list</span><br></pre></td></tr></table></figure><p>升级到 backports 内核：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get -t jessie-backports install linux-image-amd64</span><br></pre></td></tr></table></figure><p>需要注意的是，升级到 backports 的内核之后，会因为 AUFS 内核模块不可用，而使用默认的 devicemapper 驱动，并且配置为 loop-lvm ，这是不推荐的。因此，不要忘记安装 Docker 后，配置 overlay2 存储层驱动。</p><h4 id="配置-GRUB-引导参数"><a href="#配置-GRUB-引导参数" class="headerlink" title="配置 GRUB 引导参数"></a>配置 GRUB 引导参数</h4><p>在 Docker 使用期间，或者在 docker info 信息中，可能会看到下面的警告信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WARNING: Your kernel does not support cgroup swap <span class="built_in">limit</span>. </span><br><span class="line">WARNING: Your kernel does not support swap <span class="built_in">limit</span> capabilities.</span><br><span class="line">Limitation discarded.</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WARNING: No memory <span class="built_in">limit</span> support</span><br><span class="line">WARNING: No swap <span class="built_in">limit</span> support</span><br><span class="line">WARNING: No oom <span class="built_in">kill</span> <span class="built_in">disable</span> support</span><br></pre></td></tr></table></figure><p>如果需要这些功能，就需要修改 GRUB 的配置文件 <code>/etc/default/grub</code> ，在 <code>GRUB_CMDLINE_LINUX</code> 中添加内核引导参数 <code>cgroup_enable=memory swapaccount=1</code> 。<br>然后更新 GRUB：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo update-grub</span><br><span class="line">$ sudo reboot</span><br></pre></td></tr></table></figure><h3 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h3><p>使用阿里云的脚本安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh -</span><br></pre></td></tr></table></figure><p>安装好后，查看docker版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker version</span><br><span class="line">Client:</span><br><span class="line"> Version:      17.04.0-ce</span><br><span class="line"> API version:  1.28</span><br><span class="line"> Go version:   go1.7.5</span><br><span class="line"> Git commit:   4845c56</span><br><span class="line"> Built:        Mon Apr  3 17:45:49 2017</span><br><span class="line"> OS/Arch:      linux/amd64</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Version:      17.04.0-ce</span><br><span class="line"> API version:  1.28 (minimum version 1.12)</span><br><span class="line"> Go version:   go1.7.5</span><br><span class="line"> Git commit:   4845c56</span><br><span class="line"> Built:        Mon Apr  3 17:45:49 2017</span><br><span class="line"> OS/Arch:      linux/amd64</span><br><span class="line"> Experimental: <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="建立Docker用户组"><a href="#建立Docker用户组" class="headerlink" title="建立Docker用户组"></a>建立Docker用户组</h3><p>默认情况下， docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。<br>建立 docker 组：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo groupadd docker</span><br></pre></td></tr></table></figure><p>将当前用户加入 docker 组：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure><h3 id="镜像加速器"><a href="#镜像加速器" class="headerlink" title="镜像加速器"></a>镜像加速器</h3><p>国内访问 Docker Hub 有时会遇到困难，此时可以配置镜像加速器。这里采用阿里云加速器: <a href="https://cr.console.aliyun.com/#/accelerator" target="_blank" rel="noopener">https://cr.console.aliyun.com/#/accelerator</a><br>在阿里云账户中可以申请加速器，会得到如 <code>https://lygalhlu.mirror.aliyuncs.com</code> 这样的地址，我们将该信息配置给Docker引擎。<br>对于使用 systemd 的系统，用 <code>systemctl enable docker</code> 启用服务后，编辑<code>/etc/systemd/system/multi-user.target.wants/docker.service</code> 文件，找到 <code>ExecStart=</code> 这一行，在这行最后添加加速器地址 <code>--registry-mirror=&lt;加速器地址&gt;</code> ，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/usr/bin/dockerd --registry-mirror=https://lygalhlu.mirror.aliyuncs.com</span><br></pre></td></tr></table></figure><p>重新加载配置并重启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h4 id="检查加速器是否生效"><a href="#检查加速器是否生效" class="headerlink" title="检查加速器是否生效"></a>检查加速器是否生效</h4><p>Linux系统下配置完加速器需要检查是否生效,如果配置中看到 <code>--registry-mirror</code>的参数，则说明配置成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ps -ef | grep dockerd</span><br><span class="line">root       520     1  0 13:43 ?        00:00:47 /usr/bin/dockerd -H fd:// --registry-mirror=https://lygalhlu.mirror.aliyuncs.com</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> gitlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker部署gitlab服务器(2)</title>
      <link href="/articles/pm/docker-gitlab2/"/>
      <url>/articles/pm/docker-gitlab2/</url>
      
        <content type="html"><![CDATA[<hr><p>接着上一篇 Docker部署gitlab服务器(1)，部署Gitlab<br>参考文档 <a href="https://docs.gitlab.com/omnibus/docker/README.html#gitlab-docker-images" target="_blank" rel="noopener">https://docs.gitlab.com/omnibus/docker/README.html#gitlab-docker-images</a></p><a id="more"></a><h3 id="下载Gitlab"><a href="#下载Gitlab" class="headerlink" title="下载Gitlab"></a>下载Gitlab</h3><p>直接执行docker命令,使用了加速器后，一会就将Gitlab下载完成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker pull gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure><h3 id="启动Gitlab"><a href="#启动Gitlab" class="headerlink" title="启动Gitlab"></a>启动Gitlab</h3><p>hostname用服务器IP。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --detach \</span><br><span class="line"> --hostname gitlab.example.com \</span><br><span class="line"> --publish 10443:443 --publish 10080:80 --publish 10022:22 \</span><br><span class="line"> --restart always \</span><br><span class="line"> --volume /srv/gitlab/config:/etc/gitlab \</span><br><span class="line"> --volume /srv/gitlab/logs:/var/<span class="built_in">log</span>/gitlab \</span><br><span class="line"> --volume /srv/gitlab/data:/var/opt/gitlab \</span><br><span class="line"> --name gitlab gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure><p>该命令将在主机系统中建立/srv目录，docker容器的相应目录映射到主机目录下实现共享。</p><p>首次启动需要花费一定的时间，需要初始化Gitlab的一些内容。</p><p>使用如下命令查看docker 容器使用情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker ps -a</span><br></pre></td></tr></table></figure><p>完成之后，直接在浏览器中打开hostname,就可以访问Gitlab应用了。</p><h3 id="配置Gitlab"><a href="#配置Gitlab" class="headerlink" title="配置Gitlab"></a>配置Gitlab</h3><p>进入docker环境中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker <span class="built_in">exec</span> -it gitlab /bin/bash</span><br></pre></td></tr></table></figure><p>可以查看Gitlab的几个运行环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ruby --version</span></span><br><span class="line"><span class="comment"># git --version</span></span><br><span class="line"><span class="comment"># redis-cli --version</span></span><br><span class="line"><span class="comment"># psql --version</span></span><br></pre></td></tr></table></figure><p>修改配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/gitlab/gitlab.rb</span></span><br></pre></td></tr></table></figure><p>具体内容可以参考前面的博文。<br>官方文档：<a href="https://docs.gitlab.com/omnibus/settings/configuration.html" target="_blank" rel="noopener">https://docs.gitlab.com/omnibus/settings/configuration.html</a></p><h3 id="更新Gitlab"><a href="#更新Gitlab" class="headerlink" title="更新Gitlab"></a>更新Gitlab</h3><p>更新Gitlab版本，首先需要停止删除当前的Gitlab容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker stop gitlab</span><br><span class="line">$ sudo docker rm gitlab</span><br></pre></td></tr></table></figure><p>然后重新 pull 最新版本的Gitlab</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker pull gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure><p>再重新执行 上面的<code>docker run</code>命令创建启动容器。</p>]]></content>
      
      
      <categories>
          
          <category> 项目管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> gitlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git多账号使用设置</title>
      <link href="/articles/pm/git-multi-account/"/>
      <url>/articles/pm/git-multi-account/</url>
      
        <content type="html"><![CDATA[<hr><p>在我们平时使用git时，可能会经常碰到，同一台机使用多个git服务器的情况，比如公司项目使用公司的git服务器，个人项目直接用Github,Git通过配置当前用户目录下的.ssh文件夹的config文件来实现这样一种使用场景。</p><a id="more"></a><h3 id="配置config文件"><a href="#配置config文件" class="headerlink" title="配置config文件"></a>配置config文件</h3><p>如果当前用户的~/.ssh/目录下不存在config文件，则手动新建一个，文本编辑器打开，填写以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#账号1配置</span></span><br><span class="line">Host 192.168.1.8         <span class="comment">#Host 服务器别名</span></span><br><span class="line">HostName 192.168.1.8<span class="comment">#HostName 服务器IP地址或主机名</span></span><br><span class="line">Port 1022<span class="comment">#ssh 端口</span></span><br><span class="line">User git<span class="comment">#User 连接服务器的用户名</span></span><br><span class="line">IdentityFile ~/.ssh/id_rsa<span class="comment">#IdentityFile 私匙文件的具体路径    </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#账号2配置</span></span><br><span class="line">Host github.com         <span class="comment">#Host 服务器别名</span></span><br><span class="line">HostName github.com<span class="comment">#HostName 服务器IP地址或主机名</span></span><br><span class="line">User git<span class="comment">#User 连接服务器的用户名</span></span><br><span class="line">IdentityFile ~/.ssh/id_rsa2<span class="comment">#IdentityFile 私匙文件的具体路径</span></span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>使用ssh -T git@Host进行测试，其中Host指上面配置的服务器别名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>结果显示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi yourname! You<span class="string">'ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure><p>说明连接成功，就可以使用了！</p>]]></content>
      
      
      <categories>
          
          <category> 项目管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker run命令介绍</title>
      <link href="/articles/docker/docker-run/"/>
      <url>/articles/docker/docker-run/</url>
      
        <content type="html"><![CDATA[<hr><p>docker run命令用于启动一个容器，是使用Docker的时候使用最多的一个命令。并且，这个命令有非常多的参数，功能也比较重要，所以本篇主要来解释下各参数的意义。<br>参考<a href="https://docs.docker.com/engine/reference/commandline/run/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/run/</a></p><a id="more"></a><h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><p>使用方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><p>参数：</p><table><thead><tr><th align="left">名称(缩写)</th><th align="left">默认值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">–add-host</td><td align="left"></td><td align="left">主机与IP的映射(host:IP)</td></tr><tr><td align="left">–attach, -a</td><td align="left"></td><td align="left">将容器中显示附加到标准输入、标准输出、标准错误接口(STDIN, STDOUT or STDERR)</td></tr><tr><td align="left">–cpu-shares,-c</td><td align="left">0</td><td align="left">设置容器CPU权重，在CPU共享场景使用</td></tr><tr><td align="left">–cap-add</td><td align="left"></td><td align="left">添加权限，权限清单详见：<a href="http://linux.die.net/man/7/capabilities" target="_blank" rel="noopener">http://linux.die.net/man/7/capabilities</a></td></tr><tr><td align="left">–cap-drop</td><td align="left"></td><td align="left">删除权限，权限清单详见：<a href="http://linux.die.net/man/7/capabilities" target="_blank" rel="noopener">http://linux.die.net/man/7/capabilities</a></td></tr><tr><td align="left">–cidfile</td><td align="left"></td><td align="left">运行容器后，在指定文件中写入容器PID值，一种典型的监控系统用法</td></tr><tr><td align="left">–cpuset</td><td align="left"></td><td align="left">设置容器可以使用哪些CPU，此参数可以用来容器独占CPU</td></tr><tr><td align="left">–detach,-d</td><td align="left">false</td><td align="left">指定容器运行于前台还是后台</td></tr><tr><td align="left">–device</td><td align="left"></td><td align="left">添加主机设备给容器，相当于设备直通</td></tr><tr><td align="left">–dns</td><td align="left"></td><td align="left">指定容器的dns服务器</td></tr><tr><td align="left">–dns-search</td><td align="left"></td><td align="left">指定容器的dns搜索域名，写入到容器的/etc/resolv.conf文件</td></tr><tr><td align="left">–env,-e</td><td align="left"></td><td align="left">指定环境变量，容器中可以使用该环境变量</td></tr><tr><td align="left">–entrypoint</td><td align="left"></td><td align="left">覆盖image的入口点</td></tr><tr><td align="left">–env-file</td><td align="left"></td><td align="left">指定环境变量文件，文件格式为每行一个环境变量</td></tr><tr><td align="left">–expose</td><td align="left"></td><td align="left">指定容器暴露的端口，即修改镜像的暴露端口</td></tr><tr><td align="left">–hostname,-h</td><td align="left"></td><td align="left">指定容器的主机名</td></tr><tr><td align="left">–interactive,-i</td><td align="left"></td><td align="left">打开STDIN，用于控制台交互</td></tr><tr><td align="left">–link</td><td align="left"></td><td align="left">指定容器间的关联，使用其他容器的IP、env等信息</td></tr><tr><td align="left">–lxc-conf</td><td align="left"></td><td align="left">指定容器的配置文件，只有在指定–exec-driver=lxc时使用</td></tr><tr><td align="left">–memory,-m</td><td align="left"></td><td align="left">指定容器的内存上限</td></tr><tr><td align="left">–name</td><td align="left"></td><td align="left">指定容器名字，后续可以通过名字进行容器管理，links特性需要使用名字</td></tr><tr><td align="left">–net</td><td align="left">default</td><td align="left">容器网络设置</td></tr><tr><td align="left">–publish-all,-P</td><td align="left">false</td><td align="left">指定容器暴露的端口</td></tr><tr><td align="left">–publish,-p</td><td align="left"></td><td align="left">指定容器暴露的端口</td></tr><tr><td align="left">–privileged</td><td align="left">false</td><td align="left">指定容器是否为特权容器，特权容器拥有所有的capabilities</td></tr><tr><td align="left">–restart</td><td align="left">no</td><td align="left">指定容器停止后的重启策略</td></tr><tr><td align="left">–rm</td><td align="left">false</td><td align="left">指定容器停止后自动删除容器(不支持以docker run -d启动的容器)</td></tr><tr><td align="left">–sig-proxy</td><td align="left">true</td><td align="left">设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和SIGKILL不能被代理</td></tr><tr><td align="left">–tty,-t</td><td align="left">false</td><td align="left">分配tty设备，该可以支持终端登录</td></tr><tr><td align="left">–user,-u</td><td align="left"></td><td align="left">指定容器的用户</td></tr><tr><td align="left">–volume,-v</td><td align="left"></td><td align="left">给容器挂载存储卷，挂载到容器的某个目录</td></tr><tr><td align="left">–volumes-from</td><td align="left"></td><td align="left">给容器挂载其他容器上的卷，挂载到容器的某个目录</td></tr><tr><td align="left">–workdir,-w</td><td align="left"></td><td align="left">指定容器的工作目录</td></tr></tbody></table><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>–restart<br>no：容器退出时不重启<br>on-failure：容器故障退出（返回值非零）时重启<br>always：容器退出时总是重启 </p><h4 id="端口暴露"><a href="#端口暴露" class="headerlink" title="端口暴露"></a>端口暴露</h4><p>-P<br>docker自动映射暴露端口；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker自动在host上打开49000到49900的端口，映射到容器（由镜像指定，或者--expose参数指定）的暴露端口；</span></span><br><span class="line">docker run -d -P training/webapp</span><br></pre></td></tr></table></figure><p>-p<br>指定端口或IP进行映射；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># host上5000号端口，映射到容器暴露的80端口；</span></span><br><span class="line">docker run -d -p 5000:80 training/webapp</span><br><span class="line"></span><br><span class="line"><span class="comment"># host上127.0.0.1:5000号端口，映射到容器暴露的80端口；</span></span><br><span class="line">docker run -d -p 127.0.0.1:5000:80 training/webapp</span><br><span class="line"></span><br><span class="line"><span class="comment"># host上127.0.0.1:随机端口，映射到容器暴露的80端口；</span></span><br><span class="line">docker run -d -p 127.0.0.1::5000 training/webapp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定udp端口；</span></span><br><span class="line">docker run -d -p 127.0.0.1:5000:5000/udp training/webapp</span><br></pre></td></tr></table></figure><h4 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h4><p>–net=bridge：使用docker daemon指定的网桥<br>–net=host：容器使用主机的网络<br>–net=container:NAME_or_ID：使用其他容器的网路，共享IP和PORT等网络资源<br>–net=none：容器使用自己的网络（类似–net=bridge），但是不进行配置</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS上安装部署Gitlab</title>
      <link href="/articles/pm/gitlab-setup/"/>
      <url>/articles/pm/gitlab-setup/</url>
      
        <content type="html"><![CDATA[<hr><p><a href="https://about.gitlab.com/" target="_blank" rel="noopener">Gitlab</a>是一款开源的版本管理系统,可实现自托管的Git项目仓库,功能类似Github.GitLab有社区版和企业版,采用Ruby on Rails开发,社区版基于MIT License,其功能基本满足中小型团队的需求.<br>更多功能看<a href="https://about.gitlab.com/features/" target="_blank" rel="noopener">https://about.gitlab.com/features/</a></p><a id="more"></a><h3 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h3><p>操作系统:CentOS7.3 64位</p><h3 id="安装版本"><a href="#安装版本" class="headerlink" title="安装版本"></a>安装版本</h3><p>GitLab社区版(GitLab Community Edition)GitLab CE</p><h3 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h3><p>GitLab有多种安装方式,目前官方提供了GitLab-CE Omnibus安装包,根据官网上的详细介绍可以选择自己操作系统对应的版本按步骤操作,这样相对会比较简单,源码安装等方式显得非常痛苦.GitLab依赖比较多,部署起来也比较大,还是推荐官方说明来安装.<br><a href="https://about.gitlab.com/downloads" target="_blank" rel="noopener">https://about.gitlab.com/downloads</a></p><h4 id="安装配置依赖"><a href="#安装配置依赖" class="headerlink" title="安装配置依赖"></a>安装配置依赖</h4><p>GitLab采用Postfix搭建邮件服务器,当然可以安装自己需求使用Sendmail或其他.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install curl policycoreutils openssh-server openssh-clients</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> sshd</span><br><span class="line">sudo systemctl start sshd</span><br><span class="line">sudo yum install postfix</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> postfix</span><br><span class="line">sudo systemctl start postfix</span><br><span class="line">sudo firewall-cmd --permanent --add-service=http</span><br><span class="line">sudo systemctl reload firewalld</span><br></pre></td></tr></table></figure><h4 id="下载GitLab-CE-Omnibus安装包"><a href="#下载GitLab-CE-Omnibus安装包" class="headerlink" title="下载GitLab-CE Omnibus安装包"></a>下载GitLab-CE Omnibus安装包</h4><p>GitLab-CE Omnibus安装包有200多M,官方的资源会比较慢,目前国内有清华大学和浙江大学两个源,我们采用浙江大学的源来下载安装.<br>浙大开源镜像站: <a href="http://mirrors.lifetoy.org/gitlab-ce/" target="_blank" rel="noopener">http://mirrors.lifetoy.org/gitlab-ce/</a></p><h5 id="Debian-Ubuntu"><a href="#Debian-Ubuntu" class="headerlink" title="Debian/Ubuntu"></a>Debian/Ubuntu</h5><p>首先信任GitLab的gpg公钥 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://packages.gitlab.com/gpg.key 2&gt; /dev/null | sudo apt-key add - &amp;&gt;/dev/null</span><br></pre></td></tr></table></figure><p>根据Debian/Ubuntu版本,将源信息写入<code>/etc/apt/sources.list.d/gitlab-ce.list</code></p><ul><li><p>Debian7(Wheezy) </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"deb http://mirrors.lifetoy.org/gitlab-ce/debian wheezy main"</span> | sudo tee -a /etc/apt/sources.list.d/gitlab-ce.list</span><br></pre></td></tr></table></figure></li><li><p>Debian8(Jessie) </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"deb http://mirrors.lifetoy.org/gitlab-ce/debian jessie main"</span> | sudo tee -a /etc/apt/sources.list.d/gitlab-ce.list</span><br></pre></td></tr></table></figure></li><li><p>Ubuntu 14.04LTS </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"deb http://mirrors.lifetoy.org/gitlab-ce/ubuntu trusty main"</span> | sudo tee -a /etc/apt/sources.list.d/gitlab-ce.list</span><br></pre></td></tr></table></figure></li></ul><p>安装GitLab-CE:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install gitlab-ce</span><br></pre></td></tr></table></figure><h5 id="CentOS-RHEL"><a href="#CentOS-RHEL" class="headerlink" title="CentOS/RHEL"></a>CentOS/RHEL</h5><p>新建/etc/yum.repos.d/gitlab-ce.repo,内容如下:</p><ul><li><p>CentOS6/REHL6</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[gitlab-ce]</span><br><span class="line">name=gitlab-ce</span><br><span class="line">baseurl=http://mirrors.lifetoy.org/gitlab-ce/yum/el6</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://packages.gitlab.com/gpg.key</span><br></pre></td></tr></table></figure></li><li><p>CentOS7/REHL7</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[gitlab-ce]</span><br><span class="line">name=gitlab-ce</span><br><span class="line">baseurl=http://mirrors.lifetoy.org/gitlab-ce/yum/el7</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://packages.gitlab.com/gpg.key</span><br></pre></td></tr></table></figure><h4 id="安装GitLab-CE"><a href="#安装GitLab-CE" class="headerlink" title="安装GitLab-CE:"></a>安装GitLab-CE:</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum makecache</span><br><span class="line">sudo yum install gitlab-ce</span><br></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>所有的GitLab配置都在<code>/etc/gitlab/gitlab.rb</code>中修改,配置完后,启动GitLab,每次修改配置后都要重新编译</p></li><li><p>修改配置<code>external_url</code><br>修改这个配置会影响GitLab里面显示的仓库链接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">external_url = <span class="string">'http://yourip:port'</span></span><br></pre></td></tr></table></figure></li></ul><p>设置ssh shell的端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab_rails[<span class="string">'gitlab_shell_ssh_port'</span>] = 9022</span><br></pre></td></tr></table></figure><ul><li>修改GitLab邮件服务器,使用腾讯企业邮箱<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">gitlab_rails[<span class="string">'smtp_enable'</span>] = <span class="literal">true</span></span><br><span class="line">gitlab_rails[<span class="string">'smtp_address'</span>] = <span class="string">"smtp.exmail.qq.com"</span></span><br><span class="line">gitlab_rails[<span class="string">'smtp_port'</span>] = 25</span><br><span class="line">gitlab_rails[<span class="string">'smtp_user_name'</span>] = <span class="string">"xxx@yy.com"</span></span><br><span class="line">gitlab_rails[<span class="string">'smtp_password'</span>] = <span class="string">"xxx"</span></span><br><span class="line">gitlab_rails[<span class="string">'smtp_domain'</span>] = <span class="string">"smtp.qq.com"</span></span><br><span class="line">gitlab_rails[<span class="string">'smtp_authentication'</span>] = <span class="string">'login'</span></span><br><span class="line">gitlab_rails[<span class="string">'smtp_enable_starttls_auto'</span>] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If your SMTP server does not like the default 'From: gitlab@localhost' you</span></span><br><span class="line"><span class="comment"># can change the 'From' with this setting.</span></span><br><span class="line">gitlab_rails[<span class="string">'gitlab_email_from'</span>] = <span class="string">'xx@yy.com'</span></span><br><span class="line">gitlab_rails[<span class="string">'gitlab_email_reply_to'</span>] = <span class="string">'xx@yy.com'</span></span><br></pre></td></tr></table></figure></li><li>重新编译:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure>现在进主机可登录GitLab了,首次登录会要求重写密码,之后就可以使用了.</li></ul><h4 id="GitLab组成"><a href="#GitLab组成" class="headerlink" title="GitLab组成"></a>GitLab组成</h4><p>GitLab部署好后,所有工程都在/opt/gitlab目录下.<br>GitLab比较大,系统部署有很多部分组成,其构成如下:</p><ul><li>gitlab-shell:用于处理Git命令和修改authorized keys列表</li><li>gitlab-workhorse:轻量级的反向代理服务器</li><li>logrotate:日志文件管理工具</li><li>nginx:静态web服务器</li><li>postgresql:数据库</li><li>redis:缓存数据库</li><li>sidekiq:用于在后台执行队列任务(异步执行)</li><li>unicorn:GitLab Rails应用是托管在这个服务器上面的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> centos </tag>
            
            <tag> gitlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS源更换,更新系统</title>
      <link href="/articles/os/centos-update/"/>
      <url>/articles/os/centos-update/</url>
      
        <content type="html"><![CDATA[<hr><p>CentOS的yum源在国内环境下基本是一个摆设,当我们要安装新程序和更新系统的时候相当吃力,目前国内的163源比较靠谱,所以记录一下修改系统的更新源的操作.</p><a id="more"></a><h3 id="更新源修改"><a href="#更新源修改" class="headerlink" title="更新源修改"></a>更新源修改</h3><p>首先备份一下系统默认的yum配置文件<code>CentOS-Base.repo</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@vm ~]<span class="comment"># cp /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak</span></span><br></pre></td></tr></table></figure><p>现在可以修改yum配置文件了:<br>把配置文件里的mirrorlist注释掉,把baseurl前注释去掉,这样系统会只根据配置的源来作yum更新安装.修改默认的源为<code>http://mirrors.163.com</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[root@vm ~]<span class="comment"># vim /etc/yum.repos.d/CentOS-Base.repo</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The mirror system uses the connecting IP address of the client and the</span></span><br><span class="line"><span class="comment"># update status of each mirror to pick mirrors that are updated to and</span></span><br><span class="line"><span class="comment"># geographically close to the client.  You should use this for CentOS updates</span></span><br><span class="line"><span class="comment"># unless you are manually picking other mirrors.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If the mirrorlist= does not work for you, as a fall back you can try the</span></span><br><span class="line"><span class="comment"># remarked out baseurl= line instead.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">[base]</span><br><span class="line">name=CentOS-<span class="variable">$releasever</span> - Base</span><br><span class="line"><span class="comment">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=os&amp;infra=$infra</span></span><br><span class="line">baseurl=http://mirrors.163.com/centos/<span class="variable">$releasever</span>/os/<span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7</span><br><span class="line"></span><br><span class="line"><span class="comment">#released updates</span></span><br><span class="line">[updates]</span><br><span class="line">name=CentOS-<span class="variable">$releasever</span> - Updates</span><br><span class="line"><span class="comment">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=updates&amp;infra=$infra</span></span><br><span class="line">baseurl=http://mirrors.163.com/centos/<span class="variable">$releasever</span>/updates/<span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7</span><br><span class="line"></span><br><span class="line"><span class="comment">#additional packages that may be useful</span></span><br><span class="line">[extras]</span><br><span class="line">name=CentOS-<span class="variable">$releasever</span> - Extras</span><br><span class="line"><span class="comment">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=extras&amp;infra=$infra</span></span><br></pre></td></tr></table></figure><p>修改好后,保存,退出!</p><h3 id="系统更新"><a href="#系统更新" class="headerlink" title="系统更新"></a>系统更新</h3><p>最后执行更新操作:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@vm ~]<span class="comment"># rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY*</span></span><br><span class="line">[root@vm ~]<span class="comment"># yum update</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> centos </tag>
            
            <tag> yum </tag>
            
            <tag> update </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo + Github 搭建个人博客</title>
      <link href="/articles/others/create-blog/"/>
      <url>/articles/others/create-blog/</url>
      
        <content type="html"><![CDATA[<hr><p>试试用Node.js的Hexo和Github来搭建个人博客，免去了维护服务器等问题，而且完全免费！</p><a id="more"></a><h3 id="1-文档"><a href="#1-文档" class="headerlink" title="1. 文档"></a>1. 文档</h3><ul><li>Hexo文档：<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></li><li>Next文档：<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">http://theme-next.iissnan.com/getting-started.html</a></li></ul><h3 id="2-环境准备"><a href="#2-环境准备" class="headerlink" title="2. 环境准备"></a>2. 环境准备</h3><ul><li><a href="https://www.git-scm.com/" target="_blank" rel="noopener">Git</a></li><li><a href="https://nodejs.org" target="_blank" rel="noopener">Node.js</a></li></ul><h3 id="3-Windows下安装部署"><a href="#3-Windows下安装部署" class="headerlink" title="3. Windows下安装部署"></a>3. Windows下安装部署</h3><h4 id="3-1-安装Git"><a href="#3-1-安装Git" class="headerlink" title="3.1 安装Git"></a>3.1 安装Git</h4><p>Windows下安装其实还是蛮简单的，全部默认，下一步，就好了。</p><p><img src="/blog_images/create_blog/Git1.png" alt="Git1"></p><p><img src="/blog_images/create_blog/Git2.png" alt="Git2"></p><p><img src="/blog_images/create_blog/Git3.png" alt="Git3"></p><p><img src="/blog_images/create_blog/Git4.png" alt="Git4"></p><p><img src="/blog_images/create_blog/Git5.png" alt="Git5"></p><p><img src="/blog_images/create_blog/Git6.png" alt="Git6"></p><p><img src="/blog_images/create_blog/Git7.png" alt="Git7"></p><p><img src="/blog_images/create_blog/Git8.png" alt="Git8"></p><p><img src="/blog_images/create_blog/Git9.png" alt="Git9"></p><p><img src="/blog_images/create_blog/Git10.png" alt="Git10"></p><p><img src="/blog_images/create_blog/Git11.png" alt="Git11"></p><p><img src="/blog_images/create_blog/Git12.png" alt="Git12"></p><h4 id="3-2-安装Node-js"><a href="#3-2-安装Node-js" class="headerlink" title="3.2 安装Node.js"></a>3.2 安装Node.js</h4><p>一样，默认选择加下一步。</p><p><img src="/blog_images/create_blog/node1.png" alt="Node1"></p><p><img src="/blog_images/create_blog/node2.png" alt="Node2"></p><p><img src="/blog_images/create_blog/node3.png" alt="Node3"></p><p><img src="/blog_images/create_blog/node4.png" alt="Node4"></p><p><img src="/blog_images/create_blog/node5.png" alt="Node5"></p><p><img src="/blog_images/create_blog/node6.png" alt="Node6"></p><p><img src="/blog_images/create_blog/node7.png" alt="Node7"></p><h4 id="3-3-安装结果检查"><a href="#3-3-安装结果检查" class="headerlink" title="3.3 安装结果检查"></a>3.3 安装结果检查</h4><p>Windows下启动命令行或PowerShell。分别输入：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; node -v</span><br><span class="line">&gt; npm -v</span><br><span class="line">&gt; git --version</span><br></pre></td></tr></table></figure><p>如果结果显示如下图，则说明各环境安装正确，可以进行后续操作。<br><img src="/blog_images/create_blog/cmd3.png" alt="cmd3"></p><h3 id="4-Debian下安装"><a href="#4-Debian下安装" class="headerlink" title="4. Debian下安装"></a>4. Debian下安装</h3><h4 id="4-1-更新系统环境软件包"><a href="#4-1-更新系统环境软件包" class="headerlink" title="4.1 更新系统环境软件包"></a>4.1 更新系统环境软件包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get upgrade</span><br></pre></td></tr></table></figure><h4 id="4-2-安装git"><a href="#4-2-安装git" class="headerlink" title="4.2 安装git"></a>4.2 安装git</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install git-core -y</span><br><span class="line">$ git --version</span><br></pre></td></tr></table></figure><p>显示版本号信息则表示安装成功。</p><h4 id="4-3-安装Node-js"><a href="#4-3-安装Node-js" class="headerlink" title="4.3 安装Node.js"></a>4.3 安装Node.js</h4><p>通过nvm来管理Node.js,安装nvm</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh</span><br></pre></td></tr></table></figure><p>如果没有wget,则安装wget先</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install wget</span><br></pre></td></tr></table></figure><p>更新配置并安装Node.js</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">source</span> ~/.profile</span><br><span class="line">$ nvm install stable</span><br><span class="line">$ node --version</span><br><span class="line">$ npm --version</span><br></pre></td></tr></table></figure><p>如果显示版本信息则表示安装成功。</p><h3 id="5-Github设置"><a href="#5-Github设置" class="headerlink" title="5. Github设置"></a>5. Github设置</h3><p>先在 <a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a> 注册一个账户，注册好后，登录，创建代码库。<br>登录后，选择界面右上角“+”号下拉，或者点击界面右侧的“New repository”，<br><img src="/blog_images/create_blog/github1.png" alt="github1"></p><p>进入代码库创建界面，在Repository name栏写yourname.github.io（yourname为你github账户名称）<br><img src="/blog_images/create_blog/github2.png" alt="github2"></p><p>代码库创建成功之后，自动跳到项目的代码库管理界面：<br><img src="/blog_images/create_blog/github3.png" alt="github3"></p><p>选择界面右侧的Settings选项卡，进入后，下拉，可以看到GitHub Pages一栏：<br><img src="/blog_images/create_blog/github4.png" alt="github4"><br>这里就是创建Pages的地方，保存即可；保存后在这里可以自定义自己的域名，将yoursite.github.io转向自己的域名。</p><h4 id="5-1-配置Git以上传远程服务器"><a href="#5-1-配置Git以上传远程服务器" class="headerlink" title="5.1 配置Git以上传远程服务器"></a>5.1 配置Git以上传远程服务器</h4><p>首先配置自己账户的身份信息，Git bash中输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"yourname"</span></span><br><span class="line">$ git config --global user.email <span class="string">"youremail"</span></span><br></pre></td></tr></table></figure><p>Github上传采用SSH密钥的方式，生成密钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"youremail"</span></span><br></pre></td></tr></table></figure><p>提示选择全默认，按三次回车即可，之后会在当前用户目录下生成一个文件夹<code>.ssh</code>里面有两个文件<code>id_rsa</code>和<code>id_rsa.pub</code>。接着进入Github，登录，进入用户设置<code>setting</code>,选择左侧的<code>SSH and GPG keys</code>,点击<code>New SSH key</code>；用文本工具打开<code>id_rsa.pub</code>，将内容拷贝到Github中的<code>Key</code>中，<code>Title</code>任意写，保存即可。</p><p>测试是否连接通github.com:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>返回</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi yourname! You<span class="symbol">'ve</span> successfully authenticated, but GitHub does <span class="keyword">not</span> provide shell <span class="keyword">access</span>.</span><br></pre></td></tr></table></figure><p>说明连接成功！</p><h3 id="6-安装配置Hexo"><a href="#6-安装配置Hexo" class="headerlink" title="6. 安装配置Hexo"></a>6. 安装配置Hexo</h3><p>在当前用户家目录下有个文件<code>.npmrc</code>这里存放nodejs的一些配置，我们将源镜像改为淘宝镜像，加快访问速度；将插件安装路径改为自己想要的路径，否则，默认hexo会安装在用户目录下的\AppData\Roaming下。</br><br>打开<code>.npmrc</code>文件，输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">registry=https://registry.npm.taobao.org/</span><br><span class="line">prefix=D:\Program Files\nodejs</span><br></pre></td></tr></table></figure><p>启动Git Bash命令行。我把Hexo安装在D:\nodejs目录里。<br>在命令行中输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>可能会有WARN，不用理会，继续输入检查是否安装成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo -v</span><br></pre></td></tr></table></figure><p>如果得到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hexo-cli: 1.0.2</span><br><span class="line">os: Windows_NT 10.0.14393 win32 x64</span><br><span class="line">http_parser: 2.7.0</span><br><span class="line">node: 6.9.4</span><br><span class="line">v8: 5.1.281.89</span><br><span class="line">uv: 1.9.1</span><br><span class="line">zlib: 1.2.8</span><br><span class="line">ares: 1.10.1-DEV</span><br><span class="line">icu: 57.1</span><br><span class="line">modules: 48</span><br><span class="line">openssl: 1.0.2j</span><br></pre></td></tr></table></figure><p>则说明安装成功。</p><h3 id="7-部署博客项目"><a href="#7-部署博客项目" class="headerlink" title="7. 部署博客项目"></a>7. 部署博客项目</h3><p>在本地目录新建一个文件夹（博客项目），右键选择Git Bash Here,启动Git Bash命令行。<br><img src="/blog_images/create_blog/hexo1.png" alt="hexo1"></p><h4 id="7-1-初始化Hexo"><a href="#7-1-初始化Hexo" class="headerlink" title="7.1 初始化Hexo"></a>7.1 初始化Hexo</h4><p>在Git Bash命令行输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure><p>等初始化完成，再输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>npm自动安装依赖的组件。</p><h4 id="7-2-启动Hexo"><a href="#7-2-启动Hexo" class="headerlink" title="7.2 启动Hexo"></a>7.2 启动Hexo</h4><p>命令行中，继续输入,以生成静态博客站：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g     <span class="comment">#或 hexo generate</span></span><br></pre></td></tr></table></figure><p>启动web服务，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s     <span class="comment">#或 hexo server</span></span><br></pre></td></tr></table></figure><p>在浏览器中打开 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> ，就可以看到运行效果。</p><h4 id="7-3-Hexo的常用命令"><a href="#7-3-Hexo的常用命令" class="headerlink" title="7.3 Hexo的常用命令"></a>7.3 Hexo的常用命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean<span class="comment">#清空缓存db.json和public文件夹</span></span><br><span class="line">$ hexo generate<span class="comment">#简写：hexo g   生成静态文件，会在当前目录下生成一个新的 public 文件夹</span></span><br><span class="line">$ hexo server<span class="comment">#简写：hexo s   启动本地web服务，可以预览站点</span></span><br><span class="line">$ hexo deploy<span class="comment">#简写：hexo d   部署到远程服务器（比如github等平台）</span></span><br><span class="line">$ hexo new <span class="string">"artical name"</span><span class="comment">#简写：hexo n   新建文章</span></span><br><span class="line">$ hexo new page <span class="string">"page name"</span><span class="comment">#新建页面</span></span><br></pre></td></tr></table></figure><h4 id="7-4-Hexo的常用组合命令"><a href="#7-4-Hexo的常用组合命令" class="headerlink" title="7.4 Hexo的常用组合命令"></a>7.4 Hexo的常用组合命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d -g<span class="comment">#生成并部署到远程服务器</span></span><br><span class="line">$ hexo s -g<span class="comment">#生成并启动web服务</span></span><br></pre></td></tr></table></figure><h4 id="7-5-功能插件"><a href="#7-5-功能插件" class="headerlink" title="7.5 功能插件"></a>7.5 功能插件</h4><h5 id="7-5-1-部署相关："><a href="#7-5-1-部署相关：" class="headerlink" title="7.5.1 部署相关："></a>7.5.1 部署相关：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h5 id="7-5-2-本地搜索"><a href="#7-5-2-本地搜索" class="headerlink" title="7.5.2 本地搜索"></a>7.5.2 本地搜索</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><p>修改站点配置文件_config.yml:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Search </span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure><p>path：索引文件的路径，相对于站点根目录。<br>field：搜索范围，默认是 post，还可以选择 page、all，设置成 all 表示搜索所有页面。<br>limit：限制搜索的条目数。</p><p> 修改主题配置文件_config.yml:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  trigger: auto</span><br><span class="line">  top_n_per_article: 1</span><br></pre></td></tr></table></figure><p>top_n_per_article 字段表示在每篇文章中显示的搜索结果数量，设成 -1 会显示每篇文章的所有搜索结果数量。<br>然后，重新部署网站即可愉快的使用本地搜索功能了。</p><h4 id="7-6-Hexo主题修改"><a href="#7-6-Hexo主题修改" class="headerlink" title="7.6 Hexo主题修改"></a>7.6 Hexo主题修改</h4><p>Hexo 默认的主题基本都不会喜欢，流行的一款主题是Next可以在 <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a> 获取。</br><br>将下载的主题改名为next,拷贝到博客目录的themes文件夹下，修改博客站点目录下的_config.yml配置文件，找到theme,修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure><p>注意：Yaml配置文件的键值对冒号后面有空格，否则配置异常；可以去 <a href="http://www.yamllint.com/" target="_blank" rel="noopener">http://www.yamllint.com/</a> 校验配置文件的有效性。<br>重新执行启动预览：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo s -g</span><br></pre></td></tr></table></figure><h4 id="7-7-全局配置文件"><a href="#7-7-全局配置文件" class="headerlink" title="7.7 全局配置文件"></a>7.7 全局配置文件</h4><p>站点下的<code>_config.yml</code>为全局配置文件，在主题目录下也有一个同名配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"># Hexo Configuration</span><br><span class="line">## Docs: https://hexo.io/docs/configuration.html</span><br><span class="line">## Source: https://github.com/hexojs/hexo/</span><br><span class="line">## 键值对，键: 值   注意键后面冒号要空一格再写值，否则异常</span><br><span class="line"></span><br><span class="line"># Site</span><br><span class="line">title: 博客名#标题博客名</span><br><span class="line">subtitle: 副标题#副标题</span><br><span class="line">description: 关键字、描述#给搜索引擎用，对站点的描述</span><br><span class="line">author: 作者#网站底部的作者名称</span><br><span class="line">language: zh-CN#语言</span><br><span class="line">email: yourname@xxx.com#联系邮箱</span><br><span class="line">timezone: Asia/Shanghai#时区,Hexo 默认使用您电脑的时区;</span><br><span class="line">#时区列表:https://en.wikipedia.org/wiki/List_of_tz_database_time_zones</span><br><span class="line"># URL 网址</span><br><span class="line">## 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。</span><br><span class="line">url: http://yoursite.com</span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/    #生成文件名字的格式</span><br><span class="line">permalink_defaults:</span><br><span class="line"></span><br><span class="line"># Directory 目录配置</span><br><span class="line">source_dir: source                      #源文件夹，这个文件夹用来存放内容。</span><br><span class="line">public_dir: public                      #公共文件夹，这个文件夹用于存放生成的站点文件。</span><br><span class="line">tag_dir: tags                           #标签文件夹</span><br><span class="line">archive_dir: archives                   #归档文件夹</span><br><span class="line">category_dir: categories                #分类文件夹</span><br><span class="line">code_dir: downloads/code                #include code 文件夹</span><br><span class="line">i18n_dir: :lang                         #国际化（i18n）文件夹</span><br><span class="line">skip_render:                            #跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。</span><br><span class="line"></span><br><span class="line"># Writing 文章</span><br><span class="line">new_post_name: :title.md                #新文章文件名</span><br><span class="line">default_layout: post                    #默认布局</span><br><span class="line">titlecase: false                        #标题转化成大写</span><br><span class="line">external_link: true                     #在新标签里打开链接</span><br><span class="line">filename_case: 0                        #转换文件名，1代表小写；2代表大写；默认为0，意思就是创建文章的时候，是否自动帮你转换文件名，默认就行，意义不大。</span><br><span class="line">render_drafts: false                    #是否渲染_drafts目录下的文章，默认为false</span><br><span class="line">post_asset_folder: false                #启动Asset文件夹</span><br><span class="line">relative_link: false                    #把链接改为与根目录的相对位址，默认false</span><br><span class="line">future: true                            #显示未来的文章，默认false</span><br><span class="line">highlight:                              #代码块设置</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true                     #显示行号</span><br><span class="line">  auto_detect: true</span><br><span class="line">  tab_replace:</span><br><span class="line"></span><br><span class="line"># Category &amp; Tag                        #分类和标签</span><br><span class="line">default_category: uncategorized         #默认分类</span><br><span class="line">category_map:                           #分类别名</span><br><span class="line">tag_map:                                #标签别名</span><br><span class="line"></span><br><span class="line"># Date / Time format                    #日期时间格式</span><br><span class="line">## Hexo uses Moment.js to parse and display date</span><br><span class="line">## You can customize the date format as defined in</span><br><span class="line">## http://momentjs.com/docs/#/displaying/format/</span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line"></span><br><span class="line"># Pagination                             #分页</span><br><span class="line">## Set per_page to 0 to disable pagination</span><br><span class="line">per_page: 10                             #每页文章数，设置成0禁用分页</span><br><span class="line">pagination_dir: page                     #分页目录</span><br><span class="line"></span><br><span class="line"># Extensions                             #插件和主题</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: next</span><br><span class="line"></span><br><span class="line"># Deployment                             #部署</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: </span><br><span class="line">    git@github.com:yourname/yourname.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h4 id="7-8-美化"><a href="#7-8-美化" class="headerlink" title="7.8 美化"></a>7.8 美化</h4><h5 id="7-8-1-显示副标题"><a href="#7-8-1-显示副标题" class="headerlink" title="7.8.1 显示副标题"></a>7.8.1 显示副标题</h5><p>在<code>themes/next/source/css/_schemes/Mist/_header.styl</code>中将 <code>.site-subtitle { display: none; }</code>注释掉</p><h5 id="7-8-2-动态背景"><a href="#7-8-2-动态背景" class="headerlink" title="7.8.2 动态背景"></a>7.8.2 动态背景</h5><p>主题配置文件中，找到<code>canvas_nest</code>，改 <code>canvas_nest: true</code>，根据<code>_config.yml</code>描述，下载对应脚本，将<code>canvas-nest</code>放在<code>\blog\themes\next\source\lib</code>目录下。</p><h5 id="7-8-3-文章结束标志"><a href="#7-8-3-文章结束标志" class="headerlink" title="7.8.3 文章结束标志"></a>7.8.3 文章结束标志</h5><p>在路径 <code>\themes\next\layout\_macro</code> 中新建 <code>passage-end-tag.swig</code> 文件,并添加以下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"text-align:center;color: #ccc;font-size:14px;"</span>&gt;</span>-------------本文结束 <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-archive"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 感谢您的阅读-------------<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着打开<code>\themes\next\layout\_macro\post.swig</code>文件，在<code>post-body</code> 之后，即<code>(END POST BODY)</code>，添加如下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if not is_index %&#125;</span><br><span class="line">  &#123;% include 'passage-end-tag.swig' %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>然后打开主题配置文件（_config.yml),在末尾添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 文章末尾添加“本文结束”标记</span><br><span class="line">passage_end_tag:</span><br><span class="line">  enabled: true</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> npm </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
